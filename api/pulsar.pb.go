// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pulsar.proto

package api

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	github_com_golang_protobuf_proto "github.com/golang/protobuf/proto"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type CompressionType int32

const (
	CompressionType_NONE CompressionType = 0
	CompressionType_LZ4  CompressionType = 1
	CompressionType_ZLIB CompressionType = 2
)

var CompressionType_name = map[int32]string{
	0: "NONE",
	1: "LZ4",
	2: "ZLIB",
}

var CompressionType_value = map[string]int32{
	"NONE": 0,
	"LZ4":  1,
	"ZLIB": 2,
}

func (x CompressionType) Enum() *CompressionType {
	p := new(CompressionType)
	*p = x
	return p
}

func (x CompressionType) String() string {
	return proto.EnumName(CompressionType_name, int32(x))
}

func (x *CompressionType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CompressionType_value, data, "CompressionType")
	if err != nil {
		return err
	}
	*x = CompressionType(value)
	return nil
}

func (CompressionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{0}
}

type ServerError int32

const (
	ServerError_UnknownError        ServerError = 0
	ServerError_MetadataError       ServerError = 1
	ServerError_PersistenceError    ServerError = 2
	ServerError_AuthenticationError ServerError = 3
	ServerError_AuthorizationError  ServerError = 4
	ServerError_ConsumerBusy        ServerError = 5
	// other consumers are connected
	ServerError_ServiceNotReady                       ServerError = 6
	ServerError_ProducerBlockedQuotaExceededError     ServerError = 7
	ServerError_ProducerBlockedQuotaExceededException ServerError = 8
	ServerError_ChecksumError                         ServerError = 9
	ServerError_UnsupportedVersionError               ServerError = 10
	ServerError_TopicNotFound                         ServerError = 11
	ServerError_SubscriptionNotFound                  ServerError = 12
	ServerError_ConsumerNotFound                      ServerError = 13
	ServerError_TooManyRequests                       ServerError = 14
	ServerError_TopicTerminatedError                  ServerError = 15
	ServerError_ProducerBusy                          ServerError = 16
	ServerError_InvalidTopicName                      ServerError = 17
)

var ServerError_name = map[int32]string{
	0:  "UnknownError",
	1:  "MetadataError",
	2:  "PersistenceError",
	3:  "AuthenticationError",
	4:  "AuthorizationError",
	5:  "ConsumerBusy",
	6:  "ServiceNotReady",
	7:  "ProducerBlockedQuotaExceededError",
	8:  "ProducerBlockedQuotaExceededException",
	9:  "ChecksumError",
	10: "UnsupportedVersionError",
	11: "TopicNotFound",
	12: "SubscriptionNotFound",
	13: "ConsumerNotFound",
	14: "TooManyRequests",
	15: "TopicTerminatedError",
	16: "ProducerBusy",
	17: "InvalidTopicName",
}

var ServerError_value = map[string]int32{
	"UnknownError":                          0,
	"MetadataError":                         1,
	"PersistenceError":                      2,
	"AuthenticationError":                   3,
	"AuthorizationError":                    4,
	"ConsumerBusy":                          5,
	"ServiceNotReady":                       6,
	"ProducerBlockedQuotaExceededError":     7,
	"ProducerBlockedQuotaExceededException": 8,
	"ChecksumError":                         9,
	"UnsupportedVersionError":               10,
	"TopicNotFound":                         11,
	"SubscriptionNotFound":                  12,
	"ConsumerNotFound":                      13,
	"TooManyRequests":                       14,
	"TopicTerminatedError":                  15,
	"ProducerBusy":                          16,
	"InvalidTopicName":                      17,
}

func (x ServerError) Enum() *ServerError {
	p := new(ServerError)
	*p = x
	return p
}

func (x ServerError) String() string {
	return proto.EnumName(ServerError_name, int32(x))
}

func (x *ServerError) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ServerError_value, data, "ServerError")
	if err != nil {
		return err
	}
	*x = ServerError(value)
	return nil
}

func (ServerError) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{1}
}

type AuthMethod int32

const (
	AuthMethod_AuthMethodNone   AuthMethod = 0
	AuthMethod_AuthMethodYcaV1  AuthMethod = 1
	AuthMethod_AuthMethodAthens AuthMethod = 2
)

var AuthMethod_name = map[int32]string{
	0: "AuthMethodNone",
	1: "AuthMethodYcaV1",
	2: "AuthMethodAthens",
}

var AuthMethod_value = map[string]int32{
	"AuthMethodNone":   0,
	"AuthMethodYcaV1":  1,
	"AuthMethodAthens": 2,
}

func (x AuthMethod) Enum() *AuthMethod {
	p := new(AuthMethod)
	*p = x
	return p
}

func (x AuthMethod) String() string {
	return proto.EnumName(AuthMethod_name, int32(x))
}

func (x *AuthMethod) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AuthMethod_value, data, "AuthMethod")
	if err != nil {
		return err
	}
	*x = AuthMethod(value)
	return nil
}

func (AuthMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{2}
}

// Each protocol version identify new features that are
// incrementally added to the protocol
type ProtocolVersion int32

const (
	ProtocolVersion_v0  ProtocolVersion = 0
	ProtocolVersion_v1  ProtocolVersion = 1
	ProtocolVersion_v2  ProtocolVersion = 2
	ProtocolVersion_v3  ProtocolVersion = 3
	ProtocolVersion_v4  ProtocolVersion = 4
	ProtocolVersion_v5  ProtocolVersion = 5
	ProtocolVersion_v6  ProtocolVersion = 6
	ProtocolVersion_v7  ProtocolVersion = 7
	ProtocolVersion_v8  ProtocolVersion = 8
	ProtocolVersion_v9  ProtocolVersion = 9
	ProtocolVersion_v10 ProtocolVersion = 10
	ProtocolVersion_v11 ProtocolVersion = 11
	ProtocolVersion_v12 ProtocolVersion = 12
	// Added CommandActiveConsumerChange
	// Added CommandGetTopicsOfNamespace
	ProtocolVersion_v13 ProtocolVersion = 13
)

var ProtocolVersion_name = map[int32]string{
	0:  "v0",
	1:  "v1",
	2:  "v2",
	3:  "v3",
	4:  "v4",
	5:  "v5",
	6:  "v6",
	7:  "v7",
	8:  "v8",
	9:  "v9",
	10: "v10",
	11: "v11",
	12: "v12",
	13: "v13",
}

var ProtocolVersion_value = map[string]int32{
	"v0":  0,
	"v1":  1,
	"v2":  2,
	"v3":  3,
	"v4":  4,
	"v5":  5,
	"v6":  6,
	"v7":  7,
	"v8":  8,
	"v9":  9,
	"v10": 10,
	"v11": 11,
	"v12": 12,
	"v13": 13,
}

func (x ProtocolVersion) Enum() *ProtocolVersion {
	p := new(ProtocolVersion)
	*p = x
	return p
}

func (x ProtocolVersion) String() string {
	return proto.EnumName(ProtocolVersion_name, int32(x))
}

func (x *ProtocolVersion) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ProtocolVersion_value, data, "ProtocolVersion")
	if err != nil {
		return err
	}
	*x = ProtocolVersion(value)
	return nil
}

func (ProtocolVersion) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{3}
}

type Schema_Type int32

const (
	Schema_None     Schema_Type = 0
	Schema_String   Schema_Type = 1
	Schema_Json     Schema_Type = 2
	Schema_Protobuf Schema_Type = 3
	Schema_Avro     Schema_Type = 4
)

var Schema_Type_name = map[int32]string{
	0: "None",
	1: "String",
	2: "Json",
	3: "Protobuf",
	4: "Avro",
}

var Schema_Type_value = map[string]int32{
	"None":     0,
	"String":   1,
	"Json":     2,
	"Protobuf": 3,
	"Avro":     4,
}

func (x Schema_Type) Enum() *Schema_Type {
	p := new(Schema_Type)
	*p = x
	return p
}

func (x Schema_Type) String() string {
	return proto.EnumName(Schema_Type_name, int32(x))
}

func (x *Schema_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Schema_Type_value, data, "Schema_Type")
	if err != nil {
		return err
	}
	*x = Schema_Type(value)
	return nil
}

func (Schema_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{0, 0}
}

type CommandSubscribe_SubType int32

const (
	CommandSubscribe_Exclusive CommandSubscribe_SubType = 0
	CommandSubscribe_Shared    CommandSubscribe_SubType = 1
	CommandSubscribe_Failover  CommandSubscribe_SubType = 2
)

var CommandSubscribe_SubType_name = map[int32]string{
	0: "Exclusive",
	1: "Shared",
	2: "Failover",
}

var CommandSubscribe_SubType_value = map[string]int32{
	"Exclusive": 0,
	"Shared":    1,
	"Failover":  2,
}

func (x CommandSubscribe_SubType) Enum() *CommandSubscribe_SubType {
	p := new(CommandSubscribe_SubType)
	*p = x
	return p
}

func (x CommandSubscribe_SubType) String() string {
	return proto.EnumName(CommandSubscribe_SubType_name, int32(x))
}

func (x *CommandSubscribe_SubType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CommandSubscribe_SubType_value, data, "CommandSubscribe_SubType")
	if err != nil {
		return err
	}
	*x = CommandSubscribe_SubType(value)
	return nil
}

func (CommandSubscribe_SubType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{9, 0}
}

type CommandSubscribe_InitialPosition int32

const (
	CommandSubscribe_Latest   CommandSubscribe_InitialPosition = 0
	CommandSubscribe_Earliest CommandSubscribe_InitialPosition = 1
)

var CommandSubscribe_InitialPosition_name = map[int32]string{
	0: "Latest",
	1: "Earliest",
}

var CommandSubscribe_InitialPosition_value = map[string]int32{
	"Latest":   0,
	"Earliest": 1,
}

func (x CommandSubscribe_InitialPosition) Enum() *CommandSubscribe_InitialPosition {
	p := new(CommandSubscribe_InitialPosition)
	*p = x
	return p
}

func (x CommandSubscribe_InitialPosition) String() string {
	return proto.EnumName(CommandSubscribe_InitialPosition_name, int32(x))
}

func (x *CommandSubscribe_InitialPosition) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CommandSubscribe_InitialPosition_value, data, "CommandSubscribe_InitialPosition")
	if err != nil {
		return err
	}
	*x = CommandSubscribe_InitialPosition(value)
	return nil
}

func (CommandSubscribe_InitialPosition) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{9, 1}
}

type CommandPartitionedTopicMetadataResponse_LookupType int32

const (
	CommandPartitionedTopicMetadataResponse_Success CommandPartitionedTopicMetadataResponse_LookupType = 0
	CommandPartitionedTopicMetadataResponse_Failed  CommandPartitionedTopicMetadataResponse_LookupType = 1
)

var CommandPartitionedTopicMetadataResponse_LookupType_name = map[int32]string{
	0: "Success",
	1: "Failed",
}

var CommandPartitionedTopicMetadataResponse_LookupType_value = map[string]int32{
	"Success": 0,
	"Failed":  1,
}

func (x CommandPartitionedTopicMetadataResponse_LookupType) Enum() *CommandPartitionedTopicMetadataResponse_LookupType {
	p := new(CommandPartitionedTopicMetadataResponse_LookupType)
	*p = x
	return p
}

func (x CommandPartitionedTopicMetadataResponse_LookupType) String() string {
	return proto.EnumName(CommandPartitionedTopicMetadataResponse_LookupType_name, int32(x))
}

func (x *CommandPartitionedTopicMetadataResponse_LookupType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CommandPartitionedTopicMetadataResponse_LookupType_value, data, "CommandPartitionedTopicMetadataResponse_LookupType")
	if err != nil {
		return err
	}
	*x = CommandPartitionedTopicMetadataResponse_LookupType(value)
	return nil
}

func (CommandPartitionedTopicMetadataResponse_LookupType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{11, 0}
}

type CommandLookupTopicResponse_LookupType int32

const (
	CommandLookupTopicResponse_Redirect CommandLookupTopicResponse_LookupType = 0
	CommandLookupTopicResponse_Connect  CommandLookupTopicResponse_LookupType = 1
	CommandLookupTopicResponse_Failed   CommandLookupTopicResponse_LookupType = 2
)

var CommandLookupTopicResponse_LookupType_name = map[int32]string{
	0: "Redirect",
	1: "Connect",
	2: "Failed",
}

var CommandLookupTopicResponse_LookupType_value = map[string]int32{
	"Redirect": 0,
	"Connect":  1,
	"Failed":   2,
}

func (x CommandLookupTopicResponse_LookupType) Enum() *CommandLookupTopicResponse_LookupType {
	p := new(CommandLookupTopicResponse_LookupType)
	*p = x
	return p
}

func (x CommandLookupTopicResponse_LookupType) String() string {
	return proto.EnumName(CommandLookupTopicResponse_LookupType_name, int32(x))
}

func (x *CommandLookupTopicResponse_LookupType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CommandLookupTopicResponse_LookupType_value, data, "CommandLookupTopicResponse_LookupType")
	if err != nil {
		return err
	}
	*x = CommandLookupTopicResponse_LookupType(value)
	return nil
}

func (CommandLookupTopicResponse_LookupType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{13, 0}
}

type CommandAck_AckType int32

const (
	CommandAck_Individual CommandAck_AckType = 0
	CommandAck_Cumulative CommandAck_AckType = 1
)

var CommandAck_AckType_name = map[int32]string{
	0: "Individual",
	1: "Cumulative",
}

var CommandAck_AckType_value = map[string]int32{
	"Individual": 0,
	"Cumulative": 1,
}

func (x CommandAck_AckType) Enum() *CommandAck_AckType {
	p := new(CommandAck_AckType)
	*p = x
	return p
}

func (x CommandAck_AckType) String() string {
	return proto.EnumName(CommandAck_AckType_name, int32(x))
}

func (x *CommandAck_AckType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CommandAck_AckType_value, data, "CommandAck_AckType")
	if err != nil {
		return err
	}
	*x = CommandAck_AckType(value)
	return nil
}

func (CommandAck_AckType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{19, 0}
}

// Acks can contain a flag to indicate the consumer
// received an invalid message that got discarded
// before being passed on to the application.
type CommandAck_ValidationError int32

const (
	CommandAck_UncompressedSizeCorruption CommandAck_ValidationError = 0
	CommandAck_DecompressionError         CommandAck_ValidationError = 1
	CommandAck_ChecksumMismatch           CommandAck_ValidationError = 2
	CommandAck_BatchDeSerializeError      CommandAck_ValidationError = 3
	CommandAck_DecryptionError            CommandAck_ValidationError = 4
)

var CommandAck_ValidationError_name = map[int32]string{
	0: "UncompressedSizeCorruption",
	1: "DecompressionError",
	2: "ChecksumMismatch",
	3: "BatchDeSerializeError",
	4: "DecryptionError",
}

var CommandAck_ValidationError_value = map[string]int32{
	"UncompressedSizeCorruption": 0,
	"DecompressionError":         1,
	"ChecksumMismatch":           2,
	"BatchDeSerializeError":      3,
	"DecryptionError":            4,
}

func (x CommandAck_ValidationError) Enum() *CommandAck_ValidationError {
	p := new(CommandAck_ValidationError)
	*p = x
	return p
}

func (x CommandAck_ValidationError) String() string {
	return proto.EnumName(CommandAck_ValidationError_name, int32(x))
}

func (x *CommandAck_ValidationError) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CommandAck_ValidationError_value, data, "CommandAck_ValidationError")
	if err != nil {
		return err
	}
	*x = CommandAck_ValidationError(value)
	return nil
}

func (CommandAck_ValidationError) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{19, 1}
}

type CommandGetTopicsOfNamespace_Mode int32

const (
	CommandGetTopicsOfNamespace_PERSISTENT     CommandGetTopicsOfNamespace_Mode = 0
	CommandGetTopicsOfNamespace_NON_PERSISTENT CommandGetTopicsOfNamespace_Mode = 1
	CommandGetTopicsOfNamespace_ALL            CommandGetTopicsOfNamespace_Mode = 2
)

var CommandGetTopicsOfNamespace_Mode_name = map[int32]string{
	0: "PERSISTENT",
	1: "NON_PERSISTENT",
	2: "ALL",
}

var CommandGetTopicsOfNamespace_Mode_value = map[string]int32{
	"PERSISTENT":     0,
	"NON_PERSISTENT": 1,
	"ALL":            2,
}

func (x CommandGetTopicsOfNamespace_Mode) Enum() *CommandGetTopicsOfNamespace_Mode {
	p := new(CommandGetTopicsOfNamespace_Mode)
	*p = x
	return p
}

func (x CommandGetTopicsOfNamespace_Mode) String() string {
	return proto.EnumName(CommandGetTopicsOfNamespace_Mode_name, int32(x))
}

func (x *CommandGetTopicsOfNamespace_Mode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CommandGetTopicsOfNamespace_Mode_value, data, "CommandGetTopicsOfNamespace_Mode")
	if err != nil {
		return err
	}
	*x = CommandGetTopicsOfNamespace_Mode(value)
	return nil
}

func (CommandGetTopicsOfNamespace_Mode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{37, 0}
}

type BaseCommand_Type int32

const (
	BaseCommand_CONNECT                           BaseCommand_Type = 2
	BaseCommand_CONNECTED                         BaseCommand_Type = 3
	BaseCommand_SUBSCRIBE                         BaseCommand_Type = 4
	BaseCommand_PRODUCER                          BaseCommand_Type = 5
	BaseCommand_SEND                              BaseCommand_Type = 6
	BaseCommand_SEND_RECEIPT                      BaseCommand_Type = 7
	BaseCommand_SEND_ERROR                        BaseCommand_Type = 8
	BaseCommand_MESSAGE                           BaseCommand_Type = 9
	BaseCommand_ACK                               BaseCommand_Type = 10
	BaseCommand_FLOW                              BaseCommand_Type = 11
	BaseCommand_UNSUBSCRIBE                       BaseCommand_Type = 12
	BaseCommand_SUCCESS                           BaseCommand_Type = 13
	BaseCommand_ERROR                             BaseCommand_Type = 14
	BaseCommand_CLOSE_PRODUCER                    BaseCommand_Type = 15
	BaseCommand_CLOSE_CONSUMER                    BaseCommand_Type = 16
	BaseCommand_PRODUCER_SUCCESS                  BaseCommand_Type = 17
	BaseCommand_PING                              BaseCommand_Type = 18
	BaseCommand_PONG                              BaseCommand_Type = 19
	BaseCommand_REDELIVER_UNACKNOWLEDGED_MESSAGES BaseCommand_Type = 20
	BaseCommand_PARTITIONED_METADATA              BaseCommand_Type = 21
	BaseCommand_PARTITIONED_METADATA_RESPONSE     BaseCommand_Type = 22
	BaseCommand_LOOKUP                            BaseCommand_Type = 23
	BaseCommand_LOOKUP_RESPONSE                   BaseCommand_Type = 24
	BaseCommand_CONSUMER_STATS                    BaseCommand_Type = 25
	BaseCommand_CONSUMER_STATS_RESPONSE           BaseCommand_Type = 26
	BaseCommand_REACHED_END_OF_TOPIC              BaseCommand_Type = 27
	BaseCommand_SEEK                              BaseCommand_Type = 28
	BaseCommand_GET_LAST_MESSAGE_ID               BaseCommand_Type = 29
	BaseCommand_GET_LAST_MESSAGE_ID_RESPONSE      BaseCommand_Type = 30
	BaseCommand_ACTIVE_CONSUMER_CHANGE            BaseCommand_Type = 31
	BaseCommand_GET_TOPICS_OF_NAMESPACE           BaseCommand_Type = 32
	BaseCommand_GET_TOPICS_OF_NAMESPACE_RESPONSE  BaseCommand_Type = 33
	BaseCommand_GET_SCHEMA                        BaseCommand_Type = 34
	BaseCommand_GET_SCHEMA_RESPONSE               BaseCommand_Type = 35
)

var BaseCommand_Type_name = map[int32]string{
	2:  "CONNECT",
	3:  "CONNECTED",
	4:  "SUBSCRIBE",
	5:  "PRODUCER",
	6:  "SEND",
	7:  "SEND_RECEIPT",
	8:  "SEND_ERROR",
	9:  "MESSAGE",
	10: "ACK",
	11: "FLOW",
	12: "UNSUBSCRIBE",
	13: "SUCCESS",
	14: "ERROR",
	15: "CLOSE_PRODUCER",
	16: "CLOSE_CONSUMER",
	17: "PRODUCER_SUCCESS",
	18: "PING",
	19: "PONG",
	20: "REDELIVER_UNACKNOWLEDGED_MESSAGES",
	21: "PARTITIONED_METADATA",
	22: "PARTITIONED_METADATA_RESPONSE",
	23: "LOOKUP",
	24: "LOOKUP_RESPONSE",
	25: "CONSUMER_STATS",
	26: "CONSUMER_STATS_RESPONSE",
	27: "REACHED_END_OF_TOPIC",
	28: "SEEK",
	29: "GET_LAST_MESSAGE_ID",
	30: "GET_LAST_MESSAGE_ID_RESPONSE",
	31: "ACTIVE_CONSUMER_CHANGE",
	32: "GET_TOPICS_OF_NAMESPACE",
	33: "GET_TOPICS_OF_NAMESPACE_RESPONSE",
	34: "GET_SCHEMA",
	35: "GET_SCHEMA_RESPONSE",
}

var BaseCommand_Type_value = map[string]int32{
	"CONNECT":                           2,
	"CONNECTED":                         3,
	"SUBSCRIBE":                         4,
	"PRODUCER":                          5,
	"SEND":                              6,
	"SEND_RECEIPT":                      7,
	"SEND_ERROR":                        8,
	"MESSAGE":                           9,
	"ACK":                               10,
	"FLOW":                              11,
	"UNSUBSCRIBE":                       12,
	"SUCCESS":                           13,
	"ERROR":                             14,
	"CLOSE_PRODUCER":                    15,
	"CLOSE_CONSUMER":                    16,
	"PRODUCER_SUCCESS":                  17,
	"PING":                              18,
	"PONG":                              19,
	"REDELIVER_UNACKNOWLEDGED_MESSAGES": 20,
	"PARTITIONED_METADATA":              21,
	"PARTITIONED_METADATA_RESPONSE":     22,
	"LOOKUP":                            23,
	"LOOKUP_RESPONSE":                   24,
	"CONSUMER_STATS":                    25,
	"CONSUMER_STATS_RESPONSE":           26,
	"REACHED_END_OF_TOPIC":              27,
	"SEEK":                              28,
	"GET_LAST_MESSAGE_ID":               29,
	"GET_LAST_MESSAGE_ID_RESPONSE":      30,
	"ACTIVE_CONSUMER_CHANGE":            31,
	"GET_TOPICS_OF_NAMESPACE":           32,
	"GET_TOPICS_OF_NAMESPACE_RESPONSE":  33,
	"GET_SCHEMA":                        34,
	"GET_SCHEMA_RESPONSE":               35,
}

func (x BaseCommand_Type) Enum() *BaseCommand_Type {
	p := new(BaseCommand_Type)
	*p = x
	return p
}

func (x BaseCommand_Type) String() string {
	return proto.EnumName(BaseCommand_Type_name, int32(x))
}

func (x *BaseCommand_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(BaseCommand_Type_value, data, "BaseCommand_Type")
	if err != nil {
		return err
	}
	*x = BaseCommand_Type(value)
	return nil
}

func (BaseCommand_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{41, 0}
}

type Schema struct {
	Name                 *string      `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	SchemaData           []byte       `protobuf:"bytes,3,req,name=schema_data,json=schemaData" json:"schema_data,omitempty"`
	Type                 *Schema_Type `protobuf:"varint,4,req,name=type,enum=pulsar.proto.Schema_Type" json:"type,omitempty"`
	Properties           []*KeyValue  `protobuf:"bytes,5,rep,name=properties" json:"properties,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Schema) Reset()         { *m = Schema{} }
func (m *Schema) String() string { return proto.CompactTextString(m) }
func (*Schema) ProtoMessage()    {}
func (*Schema) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{0}
}
func (m *Schema) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Schema) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Schema.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Schema) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Schema.Merge(m, src)
}
func (m *Schema) XXX_Size() int {
	return m.Size()
}
func (m *Schema) XXX_DiscardUnknown() {
	xxx_messageInfo_Schema.DiscardUnknown(m)
}

var xxx_messageInfo_Schema proto.InternalMessageInfo

func (m *Schema) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Schema) GetSchemaData() []byte {
	if m != nil {
		return m.SchemaData
	}
	return nil
}

func (m *Schema) GetType() Schema_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Schema_None
}

func (m *Schema) GetProperties() []*KeyValue {
	if m != nil {
		return m.Properties
	}
	return nil
}

type MessageIdData struct {
	LedgerId             *uint64  `protobuf:"varint,1,req,name=ledgerId" json:"ledgerId,omitempty"`
	EntryId              *uint64  `protobuf:"varint,2,req,name=entryId" json:"entryId,omitempty"`
	Partition            *int32   `protobuf:"varint,3,opt,name=partition,def=-1" json:"partition,omitempty"`
	BatchIndex           *int32   `protobuf:"varint,4,opt,name=batch_index,json=batchIndex,def=-1" json:"batch_index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageIdData) Reset()         { *m = MessageIdData{} }
func (m *MessageIdData) String() string { return proto.CompactTextString(m) }
func (*MessageIdData) ProtoMessage()    {}
func (*MessageIdData) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{1}
}
func (m *MessageIdData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageIdData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageIdData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageIdData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageIdData.Merge(m, src)
}
func (m *MessageIdData) XXX_Size() int {
	return m.Size()
}
func (m *MessageIdData) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageIdData.DiscardUnknown(m)
}

var xxx_messageInfo_MessageIdData proto.InternalMessageInfo

const Default_MessageIdData_Partition int32 = -1
const Default_MessageIdData_BatchIndex int32 = -1

func (m *MessageIdData) GetLedgerId() uint64 {
	if m != nil && m.LedgerId != nil {
		return *m.LedgerId
	}
	return 0
}

func (m *MessageIdData) GetEntryId() uint64 {
	if m != nil && m.EntryId != nil {
		return *m.EntryId
	}
	return 0
}

func (m *MessageIdData) GetPartition() int32 {
	if m != nil && m.Partition != nil {
		return *m.Partition
	}
	return Default_MessageIdData_Partition
}

func (m *MessageIdData) GetBatchIndex() int32 {
	if m != nil && m.BatchIndex != nil {
		return *m.BatchIndex
	}
	return Default_MessageIdData_BatchIndex
}

type KeyValue struct {
	Key                  *string  `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Value                *string  `protobuf:"bytes,2,req,name=value" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeyValue) Reset()         { *m = KeyValue{} }
func (m *KeyValue) String() string { return proto.CompactTextString(m) }
func (*KeyValue) ProtoMessage()    {}
func (*KeyValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{2}
}
func (m *KeyValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyValue.Merge(m, src)
}
func (m *KeyValue) XXX_Size() int {
	return m.Size()
}
func (m *KeyValue) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyValue.DiscardUnknown(m)
}

var xxx_messageInfo_KeyValue proto.InternalMessageInfo

func (m *KeyValue) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *KeyValue) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type KeyLongValue struct {
	Key                  *string  `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Value                *uint64  `protobuf:"varint,2,req,name=value" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeyLongValue) Reset()         { *m = KeyLongValue{} }
func (m *KeyLongValue) String() string { return proto.CompactTextString(m) }
func (*KeyLongValue) ProtoMessage()    {}
func (*KeyLongValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{3}
}
func (m *KeyLongValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyLongValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyLongValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyLongValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyLongValue.Merge(m, src)
}
func (m *KeyLongValue) XXX_Size() int {
	return m.Size()
}
func (m *KeyLongValue) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyLongValue.DiscardUnknown(m)
}

var xxx_messageInfo_KeyLongValue proto.InternalMessageInfo

func (m *KeyLongValue) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *KeyLongValue) GetValue() uint64 {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return 0
}

type EncryptionKeys struct {
	Key                  *string     `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Value                []byte      `protobuf:"bytes,2,req,name=value" json:"value,omitempty"`
	Metadata             []*KeyValue `protobuf:"bytes,3,rep,name=metadata" json:"metadata,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *EncryptionKeys) Reset()         { *m = EncryptionKeys{} }
func (m *EncryptionKeys) String() string { return proto.CompactTextString(m) }
func (*EncryptionKeys) ProtoMessage()    {}
func (*EncryptionKeys) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{4}
}
func (m *EncryptionKeys) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptionKeys) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptionKeys.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptionKeys) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptionKeys.Merge(m, src)
}
func (m *EncryptionKeys) XXX_Size() int {
	return m.Size()
}
func (m *EncryptionKeys) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptionKeys.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptionKeys proto.InternalMessageInfo

func (m *EncryptionKeys) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *EncryptionKeys) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *EncryptionKeys) GetMetadata() []*KeyValue {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type MessageMetadata struct {
	ProducerName *string     `protobuf:"bytes,1,req,name=producer_name,json=producerName" json:"producer_name,omitempty"`
	SequenceId   *uint64     `protobuf:"varint,2,req,name=sequence_id,json=sequenceId" json:"sequence_id,omitempty"`
	PublishTime  *uint64     `protobuf:"varint,3,req,name=publish_time,json=publishTime" json:"publish_time,omitempty"`
	Properties   []*KeyValue `protobuf:"bytes,4,rep,name=properties" json:"properties,omitempty"`
	// Property set on replicated message,
	// includes the source cluster name
	ReplicatedFrom *string `protobuf:"bytes,5,opt,name=replicated_from,json=replicatedFrom" json:"replicated_from,omitempty"`
	// key to decide partition for the msg
	PartitionKey *string `protobuf:"bytes,6,opt,name=partition_key,json=partitionKey" json:"partition_key,omitempty"`
	// Override namespace's replication
	ReplicateTo      []string         `protobuf:"bytes,7,rep,name=replicate_to,json=replicateTo" json:"replicate_to,omitempty"`
	Compression      *CompressionType `protobuf:"varint,8,opt,name=compression,enum=pulsar.proto.CompressionType,def=0" json:"compression,omitempty"`
	UncompressedSize *uint32          `protobuf:"varint,9,opt,name=uncompressed_size,json=uncompressedSize,def=0" json:"uncompressed_size,omitempty"`
	// Removed below checksum field from Metadata as
	// it should be part of send-command which keeps checksum of header + payload
	// optional sfixed64 checksum = 10;
	// differentiate single and batch message metadata
	NumMessagesInBatch *int32 `protobuf:"varint,11,opt,name=num_messages_in_batch,json=numMessagesInBatch,def=1" json:"num_messages_in_batch,omitempty"`
	// the timestamp that this event occurs. it is typically set by applications.
	// if this field is omitted, `publish_time` can be used for the purpose of `event_time`.
	EventTime *uint64 `protobuf:"varint,12,opt,name=event_time,json=eventTime,def=0" json:"event_time,omitempty"`
	// Contains encryption key name, encrypted key and metadata to describe the key
	EncryptionKeys []*EncryptionKeys `protobuf:"bytes,13,rep,name=encryption_keys,json=encryptionKeys" json:"encryption_keys,omitempty"`
	// Algorithm used to encrypt data key
	EncryptionAlgo *string `protobuf:"bytes,14,opt,name=encryption_algo,json=encryptionAlgo" json:"encryption_algo,omitempty"`
	// Additional parameters required by encryption
	EncryptionParam        []byte   `protobuf:"bytes,15,opt,name=encryption_param,json=encryptionParam" json:"encryption_param,omitempty"`
	SchemaVersion          []byte   `protobuf:"bytes,16,opt,name=schema_version,json=schemaVersion" json:"schema_version,omitempty"`
	PartitionKeyB64Encoded *bool    `protobuf:"varint,17,opt,name=partition_key_b64_encoded,json=partitionKeyB64Encoded,def=0" json:"partition_key_b64_encoded,omitempty"`
	XXX_NoUnkeyedLiteral   struct{} `json:"-"`
	XXX_unrecognized       []byte   `json:"-"`
	XXX_sizecache          int32    `json:"-"`
}

func (m *MessageMetadata) Reset()         { *m = MessageMetadata{} }
func (m *MessageMetadata) String() string { return proto.CompactTextString(m) }
func (*MessageMetadata) ProtoMessage()    {}
func (*MessageMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{5}
}
func (m *MessageMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageMetadata.Merge(m, src)
}
func (m *MessageMetadata) XXX_Size() int {
	return m.Size()
}
func (m *MessageMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_MessageMetadata proto.InternalMessageInfo

const Default_MessageMetadata_Compression CompressionType = CompressionType_NONE
const Default_MessageMetadata_UncompressedSize uint32 = 0
const Default_MessageMetadata_NumMessagesInBatch int32 = 1
const Default_MessageMetadata_EventTime uint64 = 0
const Default_MessageMetadata_PartitionKeyB64Encoded bool = false

func (m *MessageMetadata) GetProducerName() string {
	if m != nil && m.ProducerName != nil {
		return *m.ProducerName
	}
	return ""
}

func (m *MessageMetadata) GetSequenceId() uint64 {
	if m != nil && m.SequenceId != nil {
		return *m.SequenceId
	}
	return 0
}

func (m *MessageMetadata) GetPublishTime() uint64 {
	if m != nil && m.PublishTime != nil {
		return *m.PublishTime
	}
	return 0
}

func (m *MessageMetadata) GetProperties() []*KeyValue {
	if m != nil {
		return m.Properties
	}
	return nil
}

func (m *MessageMetadata) GetReplicatedFrom() string {
	if m != nil && m.ReplicatedFrom != nil {
		return *m.ReplicatedFrom
	}
	return ""
}

func (m *MessageMetadata) GetPartitionKey() string {
	if m != nil && m.PartitionKey != nil {
		return *m.PartitionKey
	}
	return ""
}

func (m *MessageMetadata) GetReplicateTo() []string {
	if m != nil {
		return m.ReplicateTo
	}
	return nil
}

func (m *MessageMetadata) GetCompression() CompressionType {
	if m != nil && m.Compression != nil {
		return *m.Compression
	}
	return Default_MessageMetadata_Compression
}

func (m *MessageMetadata) GetUncompressedSize() uint32 {
	if m != nil && m.UncompressedSize != nil {
		return *m.UncompressedSize
	}
	return Default_MessageMetadata_UncompressedSize
}

func (m *MessageMetadata) GetNumMessagesInBatch() int32 {
	if m != nil && m.NumMessagesInBatch != nil {
		return *m.NumMessagesInBatch
	}
	return Default_MessageMetadata_NumMessagesInBatch
}

func (m *MessageMetadata) GetEventTime() uint64 {
	if m != nil && m.EventTime != nil {
		return *m.EventTime
	}
	return Default_MessageMetadata_EventTime
}

func (m *MessageMetadata) GetEncryptionKeys() []*EncryptionKeys {
	if m != nil {
		return m.EncryptionKeys
	}
	return nil
}

func (m *MessageMetadata) GetEncryptionAlgo() string {
	if m != nil && m.EncryptionAlgo != nil {
		return *m.EncryptionAlgo
	}
	return ""
}

func (m *MessageMetadata) GetEncryptionParam() []byte {
	if m != nil {
		return m.EncryptionParam
	}
	return nil
}

func (m *MessageMetadata) GetSchemaVersion() []byte {
	if m != nil {
		return m.SchemaVersion
	}
	return nil
}

func (m *MessageMetadata) GetPartitionKeyB64Encoded() bool {
	if m != nil && m.PartitionKeyB64Encoded != nil {
		return *m.PartitionKeyB64Encoded
	}
	return Default_MessageMetadata_PartitionKeyB64Encoded
}

type SingleMessageMetadata struct {
	Properties   []*KeyValue `protobuf:"bytes,1,rep,name=properties" json:"properties,omitempty"`
	PartitionKey *string     `protobuf:"bytes,2,opt,name=partition_key,json=partitionKey" json:"partition_key,omitempty"`
	PayloadSize  *int32      `protobuf:"varint,3,req,name=payload_size,json=payloadSize" json:"payload_size,omitempty"`
	CompactedOut *bool       `protobuf:"varint,4,opt,name=compacted_out,json=compactedOut,def=0" json:"compacted_out,omitempty"`
	// the timestamp that this event occurs. it is typically set by applications.
	// if this field is omitted, `publish_time` can be used for the purpose of `event_time`.
	EventTime              *uint64  `protobuf:"varint,5,opt,name=event_time,json=eventTime,def=0" json:"event_time,omitempty"`
	PartitionKeyB64Encoded *bool    `protobuf:"varint,6,opt,name=partition_key_b64_encoded,json=partitionKeyB64Encoded,def=0" json:"partition_key_b64_encoded,omitempty"`
	XXX_NoUnkeyedLiteral   struct{} `json:"-"`
	XXX_unrecognized       []byte   `json:"-"`
	XXX_sizecache          int32    `json:"-"`
}

func (m *SingleMessageMetadata) Reset()         { *m = SingleMessageMetadata{} }
func (m *SingleMessageMetadata) String() string { return proto.CompactTextString(m) }
func (*SingleMessageMetadata) ProtoMessage()    {}
func (*SingleMessageMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{6}
}
func (m *SingleMessageMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SingleMessageMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SingleMessageMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SingleMessageMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SingleMessageMetadata.Merge(m, src)
}
func (m *SingleMessageMetadata) XXX_Size() int {
	return m.Size()
}
func (m *SingleMessageMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_SingleMessageMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_SingleMessageMetadata proto.InternalMessageInfo

const Default_SingleMessageMetadata_CompactedOut bool = false
const Default_SingleMessageMetadata_EventTime uint64 = 0
const Default_SingleMessageMetadata_PartitionKeyB64Encoded bool = false

func (m *SingleMessageMetadata) GetProperties() []*KeyValue {
	if m != nil {
		return m.Properties
	}
	return nil
}

func (m *SingleMessageMetadata) GetPartitionKey() string {
	if m != nil && m.PartitionKey != nil {
		return *m.PartitionKey
	}
	return ""
}

func (m *SingleMessageMetadata) GetPayloadSize() int32 {
	if m != nil && m.PayloadSize != nil {
		return *m.PayloadSize
	}
	return 0
}

func (m *SingleMessageMetadata) GetCompactedOut() bool {
	if m != nil && m.CompactedOut != nil {
		return *m.CompactedOut
	}
	return Default_SingleMessageMetadata_CompactedOut
}

func (m *SingleMessageMetadata) GetEventTime() uint64 {
	if m != nil && m.EventTime != nil {
		return *m.EventTime
	}
	return Default_SingleMessageMetadata_EventTime
}

func (m *SingleMessageMetadata) GetPartitionKeyB64Encoded() bool {
	if m != nil && m.PartitionKeyB64Encoded != nil {
		return *m.PartitionKeyB64Encoded
	}
	return Default_SingleMessageMetadata_PartitionKeyB64Encoded
}

type CommandConnect struct {
	ClientVersion   *string     `protobuf:"bytes,1,req,name=client_version,json=clientVersion" json:"client_version,omitempty"`
	AuthMethod      *AuthMethod `protobuf:"varint,2,opt,name=auth_method,json=authMethod,enum=pulsar.proto.AuthMethod" json:"auth_method,omitempty"`
	AuthMethodName  *string     `protobuf:"bytes,5,opt,name=auth_method_name,json=authMethodName" json:"auth_method_name,omitempty"`
	AuthData        []byte      `protobuf:"bytes,3,opt,name=auth_data,json=authData" json:"auth_data,omitempty"`
	ProtocolVersion *int32      `protobuf:"varint,4,opt,name=protocol_version,json=protocolVersion,def=0" json:"protocol_version,omitempty"`
	// Client can ask to be proxyied to a specific broker
	// This is only honored by a Pulsar proxy
	ProxyToBrokerUrl *string `protobuf:"bytes,6,opt,name=proxy_to_broker_url,json=proxyToBrokerUrl" json:"proxy_to_broker_url,omitempty"`
	// Original principal that was verified by
	// a Pulsar proxy. In this case the auth info above
	// will be the auth of the proxy itself
	OriginalPrincipal *string `protobuf:"bytes,7,opt,name=original_principal,json=originalPrincipal" json:"original_principal,omitempty"`
	// Original auth role and auth Method that was passed
	// to the proxy. In this case the auth info above
	// will be the auth of the proxy itself
	OriginalAuthData     *string  `protobuf:"bytes,8,opt,name=original_auth_data,json=originalAuthData" json:"original_auth_data,omitempty"`
	OriginalAuthMethod   *string  `protobuf:"bytes,9,opt,name=original_auth_method,json=originalAuthMethod" json:"original_auth_method,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandConnect) Reset()         { *m = CommandConnect{} }
func (m *CommandConnect) String() string { return proto.CompactTextString(m) }
func (*CommandConnect) ProtoMessage()    {}
func (*CommandConnect) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{7}
}
func (m *CommandConnect) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandConnect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandConnect.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandConnect) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandConnect.Merge(m, src)
}
func (m *CommandConnect) XXX_Size() int {
	return m.Size()
}
func (m *CommandConnect) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandConnect.DiscardUnknown(m)
}

var xxx_messageInfo_CommandConnect proto.InternalMessageInfo

const Default_CommandConnect_ProtocolVersion int32 = 0

func (m *CommandConnect) GetClientVersion() string {
	if m != nil && m.ClientVersion != nil {
		return *m.ClientVersion
	}
	return ""
}

func (m *CommandConnect) GetAuthMethod() AuthMethod {
	if m != nil && m.AuthMethod != nil {
		return *m.AuthMethod
	}
	return AuthMethod_AuthMethodNone
}

func (m *CommandConnect) GetAuthMethodName() string {
	if m != nil && m.AuthMethodName != nil {
		return *m.AuthMethodName
	}
	return ""
}

func (m *CommandConnect) GetAuthData() []byte {
	if m != nil {
		return m.AuthData
	}
	return nil
}

func (m *CommandConnect) GetProtocolVersion() int32 {
	if m != nil && m.ProtocolVersion != nil {
		return *m.ProtocolVersion
	}
	return Default_CommandConnect_ProtocolVersion
}

func (m *CommandConnect) GetProxyToBrokerUrl() string {
	if m != nil && m.ProxyToBrokerUrl != nil {
		return *m.ProxyToBrokerUrl
	}
	return ""
}

func (m *CommandConnect) GetOriginalPrincipal() string {
	if m != nil && m.OriginalPrincipal != nil {
		return *m.OriginalPrincipal
	}
	return ""
}

func (m *CommandConnect) GetOriginalAuthData() string {
	if m != nil && m.OriginalAuthData != nil {
		return *m.OriginalAuthData
	}
	return ""
}

func (m *CommandConnect) GetOriginalAuthMethod() string {
	if m != nil && m.OriginalAuthMethod != nil {
		return *m.OriginalAuthMethod
	}
	return ""
}

type CommandConnected struct {
	ServerVersion        *string  `protobuf:"bytes,1,req,name=server_version,json=serverVersion" json:"server_version,omitempty"`
	ProtocolVersion      *int32   `protobuf:"varint,2,opt,name=protocol_version,json=protocolVersion,def=0" json:"protocol_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandConnected) Reset()         { *m = CommandConnected{} }
func (m *CommandConnected) String() string { return proto.CompactTextString(m) }
func (*CommandConnected) ProtoMessage()    {}
func (*CommandConnected) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{8}
}
func (m *CommandConnected) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandConnected) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandConnected.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandConnected) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandConnected.Merge(m, src)
}
func (m *CommandConnected) XXX_Size() int {
	return m.Size()
}
func (m *CommandConnected) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandConnected.DiscardUnknown(m)
}

var xxx_messageInfo_CommandConnected proto.InternalMessageInfo

const Default_CommandConnected_ProtocolVersion int32 = 0

func (m *CommandConnected) GetServerVersion() string {
	if m != nil && m.ServerVersion != nil {
		return *m.ServerVersion
	}
	return ""
}

func (m *CommandConnected) GetProtocolVersion() int32 {
	if m != nil && m.ProtocolVersion != nil {
		return *m.ProtocolVersion
	}
	return Default_CommandConnected_ProtocolVersion
}

type CommandSubscribe struct {
	Topic         *string                   `protobuf:"bytes,1,req,name=topic" json:"topic,omitempty"`
	Subscription  *string                   `protobuf:"bytes,2,req,name=subscription" json:"subscription,omitempty"`
	SubType       *CommandSubscribe_SubType `protobuf:"varint,3,req,name=subType,enum=pulsar.proto.CommandSubscribe_SubType" json:"subType,omitempty"`
	ConsumerId    *uint64                   `protobuf:"varint,4,req,name=consumer_id,json=consumerId" json:"consumer_id,omitempty"`
	RequestId     *uint64                   `protobuf:"varint,5,req,name=request_id,json=requestId" json:"request_id,omitempty"`
	ConsumerName  *string                   `protobuf:"bytes,6,opt,name=consumer_name,json=consumerName" json:"consumer_name,omitempty"`
	PriorityLevel *int32                    `protobuf:"varint,7,opt,name=priority_level,json=priorityLevel" json:"priority_level,omitempty"`
	// Signal wether the subscription should be backed by a
	// durable cursor or not
	Durable *bool `protobuf:"varint,8,opt,name=durable,def=1" json:"durable,omitempty"`
	// If specified, the subscription will position the cursor
	// markd-delete position  on the particular message id and
	// will send messages from that point
	StartMessageId *MessageIdData `protobuf:"bytes,9,opt,name=start_message_id,json=startMessageId" json:"start_message_id,omitempty"`
	/// Add optional metadata key=value to this consumer
	Metadata      []*KeyValue `protobuf:"bytes,10,rep,name=metadata" json:"metadata,omitempty"`
	ReadCompacted *bool       `protobuf:"varint,11,opt,name=read_compacted,json=readCompacted" json:"read_compacted,omitempty"`
	Schema        *Schema     `protobuf:"bytes,12,opt,name=schema" json:"schema,omitempty"`
	// Signal wthether the subscription will initialize on latest
	// or not -- earliest
	InitialPosition      *CommandSubscribe_InitialPosition `protobuf:"varint,13,opt,name=initialPosition,enum=pulsar.proto.CommandSubscribe_InitialPosition,def=0" json:"initialPosition,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                          `json:"-"`
	XXX_unrecognized     []byte                            `json:"-"`
	XXX_sizecache        int32                             `json:"-"`
}

func (m *CommandSubscribe) Reset()         { *m = CommandSubscribe{} }
func (m *CommandSubscribe) String() string { return proto.CompactTextString(m) }
func (*CommandSubscribe) ProtoMessage()    {}
func (*CommandSubscribe) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{9}
}
func (m *CommandSubscribe) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandSubscribe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandSubscribe.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandSubscribe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandSubscribe.Merge(m, src)
}
func (m *CommandSubscribe) XXX_Size() int {
	return m.Size()
}
func (m *CommandSubscribe) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandSubscribe.DiscardUnknown(m)
}

var xxx_messageInfo_CommandSubscribe proto.InternalMessageInfo

const Default_CommandSubscribe_Durable bool = true
const Default_CommandSubscribe_InitialPosition CommandSubscribe_InitialPosition = CommandSubscribe_Latest

func (m *CommandSubscribe) GetTopic() string {
	if m != nil && m.Topic != nil {
		return *m.Topic
	}
	return ""
}

func (m *CommandSubscribe) GetSubscription() string {
	if m != nil && m.Subscription != nil {
		return *m.Subscription
	}
	return ""
}

func (m *CommandSubscribe) GetSubType() CommandSubscribe_SubType {
	if m != nil && m.SubType != nil {
		return *m.SubType
	}
	return CommandSubscribe_Exclusive
}

func (m *CommandSubscribe) GetConsumerId() uint64 {
	if m != nil && m.ConsumerId != nil {
		return *m.ConsumerId
	}
	return 0
}

func (m *CommandSubscribe) GetRequestId() uint64 {
	if m != nil && m.RequestId != nil {
		return *m.RequestId
	}
	return 0
}

func (m *CommandSubscribe) GetConsumerName() string {
	if m != nil && m.ConsumerName != nil {
		return *m.ConsumerName
	}
	return ""
}

func (m *CommandSubscribe) GetPriorityLevel() int32 {
	if m != nil && m.PriorityLevel != nil {
		return *m.PriorityLevel
	}
	return 0
}

func (m *CommandSubscribe) GetDurable() bool {
	if m != nil && m.Durable != nil {
		return *m.Durable
	}
	return Default_CommandSubscribe_Durable
}

func (m *CommandSubscribe) GetStartMessageId() *MessageIdData {
	if m != nil {
		return m.StartMessageId
	}
	return nil
}

func (m *CommandSubscribe) GetMetadata() []*KeyValue {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *CommandSubscribe) GetReadCompacted() bool {
	if m != nil && m.ReadCompacted != nil {
		return *m.ReadCompacted
	}
	return false
}

func (m *CommandSubscribe) GetSchema() *Schema {
	if m != nil {
		return m.Schema
	}
	return nil
}

func (m *CommandSubscribe) GetInitialPosition() CommandSubscribe_InitialPosition {
	if m != nil && m.InitialPosition != nil {
		return *m.InitialPosition
	}
	return Default_CommandSubscribe_InitialPosition
}

type CommandPartitionedTopicMetadata struct {
	Topic     *string `protobuf:"bytes,1,req,name=topic" json:"topic,omitempty"`
	RequestId *uint64 `protobuf:"varint,2,req,name=request_id,json=requestId" json:"request_id,omitempty"`
	// TODO - Remove original_principal, original_auth_data, original_auth_method
	// Original principal that was verified by
	// a Pulsar proxy.
	OriginalPrincipal *string `protobuf:"bytes,3,opt,name=original_principal,json=originalPrincipal" json:"original_principal,omitempty"`
	// Original auth role and auth Method that was passed
	// to the proxy.
	OriginalAuthData     *string  `protobuf:"bytes,4,opt,name=original_auth_data,json=originalAuthData" json:"original_auth_data,omitempty"`
	OriginalAuthMethod   *string  `protobuf:"bytes,5,opt,name=original_auth_method,json=originalAuthMethod" json:"original_auth_method,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandPartitionedTopicMetadata) Reset()         { *m = CommandPartitionedTopicMetadata{} }
func (m *CommandPartitionedTopicMetadata) String() string { return proto.CompactTextString(m) }
func (*CommandPartitionedTopicMetadata) ProtoMessage()    {}
func (*CommandPartitionedTopicMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{10}
}
func (m *CommandPartitionedTopicMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandPartitionedTopicMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandPartitionedTopicMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandPartitionedTopicMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandPartitionedTopicMetadata.Merge(m, src)
}
func (m *CommandPartitionedTopicMetadata) XXX_Size() int {
	return m.Size()
}
func (m *CommandPartitionedTopicMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandPartitionedTopicMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_CommandPartitionedTopicMetadata proto.InternalMessageInfo

func (m *CommandPartitionedTopicMetadata) GetTopic() string {
	if m != nil && m.Topic != nil {
		return *m.Topic
	}
	return ""
}

func (m *CommandPartitionedTopicMetadata) GetRequestId() uint64 {
	if m != nil && m.RequestId != nil {
		return *m.RequestId
	}
	return 0
}

func (m *CommandPartitionedTopicMetadata) GetOriginalPrincipal() string {
	if m != nil && m.OriginalPrincipal != nil {
		return *m.OriginalPrincipal
	}
	return ""
}

func (m *CommandPartitionedTopicMetadata) GetOriginalAuthData() string {
	if m != nil && m.OriginalAuthData != nil {
		return *m.OriginalAuthData
	}
	return ""
}

func (m *CommandPartitionedTopicMetadata) GetOriginalAuthMethod() string {
	if m != nil && m.OriginalAuthMethod != nil {
		return *m.OriginalAuthMethod
	}
	return ""
}

type CommandPartitionedTopicMetadataResponse struct {
	Partitions           *uint32                                             `protobuf:"varint,1,opt,name=partitions" json:"partitions,omitempty"`
	RequestId            *uint64                                             `protobuf:"varint,2,req,name=request_id,json=requestId" json:"request_id,omitempty"`
	Response             *CommandPartitionedTopicMetadataResponse_LookupType `protobuf:"varint,3,opt,name=response,enum=pulsar.proto.CommandPartitionedTopicMetadataResponse_LookupType" json:"response,omitempty"`
	Error                *ServerError                                        `protobuf:"varint,4,opt,name=error,enum=pulsar.proto.ServerError" json:"error,omitempty"`
	Message              *string                                             `protobuf:"bytes,5,opt,name=message" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                            `json:"-"`
	XXX_unrecognized     []byte                                              `json:"-"`
	XXX_sizecache        int32                                               `json:"-"`
}

func (m *CommandPartitionedTopicMetadataResponse) Reset() {
	*m = CommandPartitionedTopicMetadataResponse{}
}
func (m *CommandPartitionedTopicMetadataResponse) String() string { return proto.CompactTextString(m) }
func (*CommandPartitionedTopicMetadataResponse) ProtoMessage()    {}
func (*CommandPartitionedTopicMetadataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{11}
}
func (m *CommandPartitionedTopicMetadataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandPartitionedTopicMetadataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandPartitionedTopicMetadataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandPartitionedTopicMetadataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandPartitionedTopicMetadataResponse.Merge(m, src)
}
func (m *CommandPartitionedTopicMetadataResponse) XXX_Size() int {
	return m.Size()
}
func (m *CommandPartitionedTopicMetadataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandPartitionedTopicMetadataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CommandPartitionedTopicMetadataResponse proto.InternalMessageInfo

func (m *CommandPartitionedTopicMetadataResponse) GetPartitions() uint32 {
	if m != nil && m.Partitions != nil {
		return *m.Partitions
	}
	return 0
}

func (m *CommandPartitionedTopicMetadataResponse) GetRequestId() uint64 {
	if m != nil && m.RequestId != nil {
		return *m.RequestId
	}
	return 0
}

func (m *CommandPartitionedTopicMetadataResponse) GetResponse() CommandPartitionedTopicMetadataResponse_LookupType {
	if m != nil && m.Response != nil {
		return *m.Response
	}
	return CommandPartitionedTopicMetadataResponse_Success
}

func (m *CommandPartitionedTopicMetadataResponse) GetError() ServerError {
	if m != nil && m.Error != nil {
		return *m.Error
	}
	return ServerError_UnknownError
}

func (m *CommandPartitionedTopicMetadataResponse) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

type CommandLookupTopic struct {
	Topic         *string `protobuf:"bytes,1,req,name=topic" json:"topic,omitempty"`
	RequestId     *uint64 `protobuf:"varint,2,req,name=request_id,json=requestId" json:"request_id,omitempty"`
	Authoritative *bool   `protobuf:"varint,3,opt,name=authoritative,def=0" json:"authoritative,omitempty"`
	// TODO - Remove original_principal, original_auth_data, original_auth_method
	// Original principal that was verified by
	// a Pulsar proxy.
	OriginalPrincipal *string `protobuf:"bytes,4,opt,name=original_principal,json=originalPrincipal" json:"original_principal,omitempty"`
	// Original auth role and auth Method that was passed
	// to the proxy.
	OriginalAuthData     *string  `protobuf:"bytes,5,opt,name=original_auth_data,json=originalAuthData" json:"original_auth_data,omitempty"`
	OriginalAuthMethod   *string  `protobuf:"bytes,6,opt,name=original_auth_method,json=originalAuthMethod" json:"original_auth_method,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandLookupTopic) Reset()         { *m = CommandLookupTopic{} }
func (m *CommandLookupTopic) String() string { return proto.CompactTextString(m) }
func (*CommandLookupTopic) ProtoMessage()    {}
func (*CommandLookupTopic) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{12}
}
func (m *CommandLookupTopic) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandLookupTopic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandLookupTopic.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandLookupTopic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandLookupTopic.Merge(m, src)
}
func (m *CommandLookupTopic) XXX_Size() int {
	return m.Size()
}
func (m *CommandLookupTopic) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandLookupTopic.DiscardUnknown(m)
}

var xxx_messageInfo_CommandLookupTopic proto.InternalMessageInfo

const Default_CommandLookupTopic_Authoritative bool = false

func (m *CommandLookupTopic) GetTopic() string {
	if m != nil && m.Topic != nil {
		return *m.Topic
	}
	return ""
}

func (m *CommandLookupTopic) GetRequestId() uint64 {
	if m != nil && m.RequestId != nil {
		return *m.RequestId
	}
	return 0
}

func (m *CommandLookupTopic) GetAuthoritative() bool {
	if m != nil && m.Authoritative != nil {
		return *m.Authoritative
	}
	return Default_CommandLookupTopic_Authoritative
}

func (m *CommandLookupTopic) GetOriginalPrincipal() string {
	if m != nil && m.OriginalPrincipal != nil {
		return *m.OriginalPrincipal
	}
	return ""
}

func (m *CommandLookupTopic) GetOriginalAuthData() string {
	if m != nil && m.OriginalAuthData != nil {
		return *m.OriginalAuthData
	}
	return ""
}

func (m *CommandLookupTopic) GetOriginalAuthMethod() string {
	if m != nil && m.OriginalAuthMethod != nil {
		return *m.OriginalAuthMethod
	}
	return ""
}

type CommandLookupTopicResponse struct {
	BrokerServiceUrl    *string                                `protobuf:"bytes,1,opt,name=brokerServiceUrl" json:"brokerServiceUrl,omitempty"`
	BrokerServiceUrlTls *string                                `protobuf:"bytes,2,opt,name=brokerServiceUrlTls" json:"brokerServiceUrlTls,omitempty"`
	Response            *CommandLookupTopicResponse_LookupType `protobuf:"varint,3,opt,name=response,enum=pulsar.proto.CommandLookupTopicResponse_LookupType" json:"response,omitempty"`
	RequestId           *uint64                                `protobuf:"varint,4,req,name=request_id,json=requestId" json:"request_id,omitempty"`
	Authoritative       *bool                                  `protobuf:"varint,5,opt,name=authoritative,def=0" json:"authoritative,omitempty"`
	Error               *ServerError                           `protobuf:"varint,6,opt,name=error,enum=pulsar.proto.ServerError" json:"error,omitempty"`
	Message             *string                                `protobuf:"bytes,7,opt,name=message" json:"message,omitempty"`
	// If it's true, indicates to the client that it must
	// always connect through the service url after the
	// lookup has been completed.
	ProxyThroughServiceUrl *bool    `protobuf:"varint,8,opt,name=proxy_through_service_url,json=proxyThroughServiceUrl,def=0" json:"proxy_through_service_url,omitempty"`
	XXX_NoUnkeyedLiteral   struct{} `json:"-"`
	XXX_unrecognized       []byte   `json:"-"`
	XXX_sizecache          int32    `json:"-"`
}

func (m *CommandLookupTopicResponse) Reset()         { *m = CommandLookupTopicResponse{} }
func (m *CommandLookupTopicResponse) String() string { return proto.CompactTextString(m) }
func (*CommandLookupTopicResponse) ProtoMessage()    {}
func (*CommandLookupTopicResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{13}
}
func (m *CommandLookupTopicResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandLookupTopicResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandLookupTopicResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandLookupTopicResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandLookupTopicResponse.Merge(m, src)
}
func (m *CommandLookupTopicResponse) XXX_Size() int {
	return m.Size()
}
func (m *CommandLookupTopicResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandLookupTopicResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CommandLookupTopicResponse proto.InternalMessageInfo

const Default_CommandLookupTopicResponse_Authoritative bool = false
const Default_CommandLookupTopicResponse_ProxyThroughServiceUrl bool = false

func (m *CommandLookupTopicResponse) GetBrokerServiceUrl() string {
	if m != nil && m.BrokerServiceUrl != nil {
		return *m.BrokerServiceUrl
	}
	return ""
}

func (m *CommandLookupTopicResponse) GetBrokerServiceUrlTls() string {
	if m != nil && m.BrokerServiceUrlTls != nil {
		return *m.BrokerServiceUrlTls
	}
	return ""
}

func (m *CommandLookupTopicResponse) GetResponse() CommandLookupTopicResponse_LookupType {
	if m != nil && m.Response != nil {
		return *m.Response
	}
	return CommandLookupTopicResponse_Redirect
}

func (m *CommandLookupTopicResponse) GetRequestId() uint64 {
	if m != nil && m.RequestId != nil {
		return *m.RequestId
	}
	return 0
}

func (m *CommandLookupTopicResponse) GetAuthoritative() bool {
	if m != nil && m.Authoritative != nil {
		return *m.Authoritative
	}
	return Default_CommandLookupTopicResponse_Authoritative
}

func (m *CommandLookupTopicResponse) GetError() ServerError {
	if m != nil && m.Error != nil {
		return *m.Error
	}
	return ServerError_UnknownError
}

func (m *CommandLookupTopicResponse) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

func (m *CommandLookupTopicResponse) GetProxyThroughServiceUrl() bool {
	if m != nil && m.ProxyThroughServiceUrl != nil {
		return *m.ProxyThroughServiceUrl
	}
	return Default_CommandLookupTopicResponse_ProxyThroughServiceUrl
}

/// Create a new Producer on a topic, assigning the given producer_id,
/// all messages sent with this producer_id will be persisted on the topic
type CommandProducer struct {
	Topic      *string `protobuf:"bytes,1,req,name=topic" json:"topic,omitempty"`
	ProducerId *uint64 `protobuf:"varint,2,req,name=producer_id,json=producerId" json:"producer_id,omitempty"`
	RequestId  *uint64 `protobuf:"varint,3,req,name=request_id,json=requestId" json:"request_id,omitempty"`
	/// If a producer name is specified, the name will be used,
	/// otherwise the broker will generate a unique name
	ProducerName *string `protobuf:"bytes,4,opt,name=producer_name,json=producerName" json:"producer_name,omitempty"`
	Encrypted    *bool   `protobuf:"varint,5,opt,name=encrypted,def=0" json:"encrypted,omitempty"`
	/// Add optional metadata key=value to this producer
	Metadata             []*KeyValue `protobuf:"bytes,6,rep,name=metadata" json:"metadata,omitempty"`
	Schema               *Schema     `protobuf:"bytes,7,opt,name=schema" json:"schema,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *CommandProducer) Reset()         { *m = CommandProducer{} }
func (m *CommandProducer) String() string { return proto.CompactTextString(m) }
func (*CommandProducer) ProtoMessage()    {}
func (*CommandProducer) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{14}
}
func (m *CommandProducer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandProducer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandProducer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandProducer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandProducer.Merge(m, src)
}
func (m *CommandProducer) XXX_Size() int {
	return m.Size()
}
func (m *CommandProducer) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandProducer.DiscardUnknown(m)
}

var xxx_messageInfo_CommandProducer proto.InternalMessageInfo

const Default_CommandProducer_Encrypted bool = false

func (m *CommandProducer) GetTopic() string {
	if m != nil && m.Topic != nil {
		return *m.Topic
	}
	return ""
}

func (m *CommandProducer) GetProducerId() uint64 {
	if m != nil && m.ProducerId != nil {
		return *m.ProducerId
	}
	return 0
}

func (m *CommandProducer) GetRequestId() uint64 {
	if m != nil && m.RequestId != nil {
		return *m.RequestId
	}
	return 0
}

func (m *CommandProducer) GetProducerName() string {
	if m != nil && m.ProducerName != nil {
		return *m.ProducerName
	}
	return ""
}

func (m *CommandProducer) GetEncrypted() bool {
	if m != nil && m.Encrypted != nil {
		return *m.Encrypted
	}
	return Default_CommandProducer_Encrypted
}

func (m *CommandProducer) GetMetadata() []*KeyValue {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *CommandProducer) GetSchema() *Schema {
	if m != nil {
		return m.Schema
	}
	return nil
}

type CommandSend struct {
	ProducerId           *uint64  `protobuf:"varint,1,req,name=producer_id,json=producerId" json:"producer_id,omitempty"`
	SequenceId           *uint64  `protobuf:"varint,2,req,name=sequence_id,json=sequenceId" json:"sequence_id,omitempty"`
	NumMessages          *int32   `protobuf:"varint,3,opt,name=num_messages,json=numMessages,def=1" json:"num_messages,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandSend) Reset()         { *m = CommandSend{} }
func (m *CommandSend) String() string { return proto.CompactTextString(m) }
func (*CommandSend) ProtoMessage()    {}
func (*CommandSend) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{15}
}
func (m *CommandSend) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandSend) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandSend.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandSend) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandSend.Merge(m, src)
}
func (m *CommandSend) XXX_Size() int {
	return m.Size()
}
func (m *CommandSend) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandSend.DiscardUnknown(m)
}

var xxx_messageInfo_CommandSend proto.InternalMessageInfo

const Default_CommandSend_NumMessages int32 = 1

func (m *CommandSend) GetProducerId() uint64 {
	if m != nil && m.ProducerId != nil {
		return *m.ProducerId
	}
	return 0
}

func (m *CommandSend) GetSequenceId() uint64 {
	if m != nil && m.SequenceId != nil {
		return *m.SequenceId
	}
	return 0
}

func (m *CommandSend) GetNumMessages() int32 {
	if m != nil && m.NumMessages != nil {
		return *m.NumMessages
	}
	return Default_CommandSend_NumMessages
}

type CommandSendReceipt struct {
	ProducerId           *uint64        `protobuf:"varint,1,req,name=producer_id,json=producerId" json:"producer_id,omitempty"`
	SequenceId           *uint64        `protobuf:"varint,2,req,name=sequence_id,json=sequenceId" json:"sequence_id,omitempty"`
	MessageId            *MessageIdData `protobuf:"bytes,3,opt,name=message_id,json=messageId" json:"message_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *CommandSendReceipt) Reset()         { *m = CommandSendReceipt{} }
func (m *CommandSendReceipt) String() string { return proto.CompactTextString(m) }
func (*CommandSendReceipt) ProtoMessage()    {}
func (*CommandSendReceipt) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{16}
}
func (m *CommandSendReceipt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandSendReceipt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandSendReceipt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandSendReceipt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandSendReceipt.Merge(m, src)
}
func (m *CommandSendReceipt) XXX_Size() int {
	return m.Size()
}
func (m *CommandSendReceipt) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandSendReceipt.DiscardUnknown(m)
}

var xxx_messageInfo_CommandSendReceipt proto.InternalMessageInfo

func (m *CommandSendReceipt) GetProducerId() uint64 {
	if m != nil && m.ProducerId != nil {
		return *m.ProducerId
	}
	return 0
}

func (m *CommandSendReceipt) GetSequenceId() uint64 {
	if m != nil && m.SequenceId != nil {
		return *m.SequenceId
	}
	return 0
}

func (m *CommandSendReceipt) GetMessageId() *MessageIdData {
	if m != nil {
		return m.MessageId
	}
	return nil
}

type CommandSendError struct {
	ProducerId           *uint64      `protobuf:"varint,1,req,name=producer_id,json=producerId" json:"producer_id,omitempty"`
	SequenceId           *uint64      `protobuf:"varint,2,req,name=sequence_id,json=sequenceId" json:"sequence_id,omitempty"`
	Error                *ServerError `protobuf:"varint,3,req,name=error,enum=pulsar.proto.ServerError" json:"error,omitempty"`
	Message              *string      `protobuf:"bytes,4,req,name=message" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *CommandSendError) Reset()         { *m = CommandSendError{} }
func (m *CommandSendError) String() string { return proto.CompactTextString(m) }
func (*CommandSendError) ProtoMessage()    {}
func (*CommandSendError) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{17}
}
func (m *CommandSendError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandSendError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandSendError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandSendError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandSendError.Merge(m, src)
}
func (m *CommandSendError) XXX_Size() int {
	return m.Size()
}
func (m *CommandSendError) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandSendError.DiscardUnknown(m)
}

var xxx_messageInfo_CommandSendError proto.InternalMessageInfo

func (m *CommandSendError) GetProducerId() uint64 {
	if m != nil && m.ProducerId != nil {
		return *m.ProducerId
	}
	return 0
}

func (m *CommandSendError) GetSequenceId() uint64 {
	if m != nil && m.SequenceId != nil {
		return *m.SequenceId
	}
	return 0
}

func (m *CommandSendError) GetError() ServerError {
	if m != nil && m.Error != nil {
		return *m.Error
	}
	return ServerError_UnknownError
}

func (m *CommandSendError) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

type CommandMessage struct {
	ConsumerId           *uint64        `protobuf:"varint,1,req,name=consumer_id,json=consumerId" json:"consumer_id,omitempty"`
	MessageId            *MessageIdData `protobuf:"bytes,2,req,name=message_id,json=messageId" json:"message_id,omitempty"`
	RedeliveryCount      *uint32        `protobuf:"varint,3,opt,name=redelivery_count,json=redeliveryCount,def=0" json:"redelivery_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *CommandMessage) Reset()         { *m = CommandMessage{} }
func (m *CommandMessage) String() string { return proto.CompactTextString(m) }
func (*CommandMessage) ProtoMessage()    {}
func (*CommandMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{18}
}
func (m *CommandMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandMessage.Merge(m, src)
}
func (m *CommandMessage) XXX_Size() int {
	return m.Size()
}
func (m *CommandMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandMessage.DiscardUnknown(m)
}

var xxx_messageInfo_CommandMessage proto.InternalMessageInfo

const Default_CommandMessage_RedeliveryCount uint32 = 0

func (m *CommandMessage) GetConsumerId() uint64 {
	if m != nil && m.ConsumerId != nil {
		return *m.ConsumerId
	}
	return 0
}

func (m *CommandMessage) GetMessageId() *MessageIdData {
	if m != nil {
		return m.MessageId
	}
	return nil
}

func (m *CommandMessage) GetRedeliveryCount() uint32 {
	if m != nil && m.RedeliveryCount != nil {
		return *m.RedeliveryCount
	}
	return Default_CommandMessage_RedeliveryCount
}

type CommandAck struct {
	ConsumerId *uint64             `protobuf:"varint,1,req,name=consumer_id,json=consumerId" json:"consumer_id,omitempty"`
	AckType    *CommandAck_AckType `protobuf:"varint,2,req,name=ack_type,json=ackType,enum=pulsar.proto.CommandAck_AckType" json:"ack_type,omitempty"`
	// In case of individual acks, the client can pass a list of message ids
	MessageId            []*MessageIdData            `protobuf:"bytes,3,rep,name=message_id,json=messageId" json:"message_id,omitempty"`
	ValidationError      *CommandAck_ValidationError `protobuf:"varint,4,opt,name=validation_error,json=validationError,enum=pulsar.proto.CommandAck_ValidationError" json:"validation_error,omitempty"`
	Properties           []*KeyLongValue             `protobuf:"bytes,5,rep,name=properties" json:"properties,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *CommandAck) Reset()         { *m = CommandAck{} }
func (m *CommandAck) String() string { return proto.CompactTextString(m) }
func (*CommandAck) ProtoMessage()    {}
func (*CommandAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{19}
}
func (m *CommandAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandAck.Merge(m, src)
}
func (m *CommandAck) XXX_Size() int {
	return m.Size()
}
func (m *CommandAck) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandAck.DiscardUnknown(m)
}

var xxx_messageInfo_CommandAck proto.InternalMessageInfo

func (m *CommandAck) GetConsumerId() uint64 {
	if m != nil && m.ConsumerId != nil {
		return *m.ConsumerId
	}
	return 0
}

func (m *CommandAck) GetAckType() CommandAck_AckType {
	if m != nil && m.AckType != nil {
		return *m.AckType
	}
	return CommandAck_Individual
}

func (m *CommandAck) GetMessageId() []*MessageIdData {
	if m != nil {
		return m.MessageId
	}
	return nil
}

func (m *CommandAck) GetValidationError() CommandAck_ValidationError {
	if m != nil && m.ValidationError != nil {
		return *m.ValidationError
	}
	return CommandAck_UncompressedSizeCorruption
}

func (m *CommandAck) GetProperties() []*KeyLongValue {
	if m != nil {
		return m.Properties
	}
	return nil
}

// changes on active consumer
type CommandActiveConsumerChange struct {
	ConsumerId           *uint64  `protobuf:"varint,1,req,name=consumer_id,json=consumerId" json:"consumer_id,omitempty"`
	IsActive             *bool    `protobuf:"varint,2,opt,name=is_active,json=isActive,def=0" json:"is_active,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandActiveConsumerChange) Reset()         { *m = CommandActiveConsumerChange{} }
func (m *CommandActiveConsumerChange) String() string { return proto.CompactTextString(m) }
func (*CommandActiveConsumerChange) ProtoMessage()    {}
func (*CommandActiveConsumerChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{20}
}
func (m *CommandActiveConsumerChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandActiveConsumerChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandActiveConsumerChange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandActiveConsumerChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandActiveConsumerChange.Merge(m, src)
}
func (m *CommandActiveConsumerChange) XXX_Size() int {
	return m.Size()
}
func (m *CommandActiveConsumerChange) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandActiveConsumerChange.DiscardUnknown(m)
}

var xxx_messageInfo_CommandActiveConsumerChange proto.InternalMessageInfo

const Default_CommandActiveConsumerChange_IsActive bool = false

func (m *CommandActiveConsumerChange) GetConsumerId() uint64 {
	if m != nil && m.ConsumerId != nil {
		return *m.ConsumerId
	}
	return 0
}

func (m *CommandActiveConsumerChange) GetIsActive() bool {
	if m != nil && m.IsActive != nil {
		return *m.IsActive
	}
	return Default_CommandActiveConsumerChange_IsActive
}

type CommandFlow struct {
	ConsumerId *uint64 `protobuf:"varint,1,req,name=consumer_id,json=consumerId" json:"consumer_id,omitempty"`
	// Max number of messages to prefetch, in addition
	// of any number previously specified
	MessagePermits       *uint32  `protobuf:"varint,2,req,name=messagePermits" json:"messagePermits,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandFlow) Reset()         { *m = CommandFlow{} }
func (m *CommandFlow) String() string { return proto.CompactTextString(m) }
func (*CommandFlow) ProtoMessage()    {}
func (*CommandFlow) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{21}
}
func (m *CommandFlow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandFlow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandFlow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandFlow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandFlow.Merge(m, src)
}
func (m *CommandFlow) XXX_Size() int {
	return m.Size()
}
func (m *CommandFlow) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandFlow.DiscardUnknown(m)
}

var xxx_messageInfo_CommandFlow proto.InternalMessageInfo

func (m *CommandFlow) GetConsumerId() uint64 {
	if m != nil && m.ConsumerId != nil {
		return *m.ConsumerId
	}
	return 0
}

func (m *CommandFlow) GetMessagePermits() uint32 {
	if m != nil && m.MessagePermits != nil {
		return *m.MessagePermits
	}
	return 0
}

type CommandUnsubscribe struct {
	ConsumerId           *uint64  `protobuf:"varint,1,req,name=consumer_id,json=consumerId" json:"consumer_id,omitempty"`
	RequestId            *uint64  `protobuf:"varint,2,req,name=request_id,json=requestId" json:"request_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandUnsubscribe) Reset()         { *m = CommandUnsubscribe{} }
func (m *CommandUnsubscribe) String() string { return proto.CompactTextString(m) }
func (*CommandUnsubscribe) ProtoMessage()    {}
func (*CommandUnsubscribe) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{22}
}
func (m *CommandUnsubscribe) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandUnsubscribe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandUnsubscribe.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandUnsubscribe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandUnsubscribe.Merge(m, src)
}
func (m *CommandUnsubscribe) XXX_Size() int {
	return m.Size()
}
func (m *CommandUnsubscribe) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandUnsubscribe.DiscardUnknown(m)
}

var xxx_messageInfo_CommandUnsubscribe proto.InternalMessageInfo

func (m *CommandUnsubscribe) GetConsumerId() uint64 {
	if m != nil && m.ConsumerId != nil {
		return *m.ConsumerId
	}
	return 0
}

func (m *CommandUnsubscribe) GetRequestId() uint64 {
	if m != nil && m.RequestId != nil {
		return *m.RequestId
	}
	return 0
}

// Reset an existing consumer to a particular message id
type CommandSeek struct {
	ConsumerId           *uint64        `protobuf:"varint,1,req,name=consumer_id,json=consumerId" json:"consumer_id,omitempty"`
	RequestId            *uint64        `protobuf:"varint,2,req,name=request_id,json=requestId" json:"request_id,omitempty"`
	MessageId            *MessageIdData `protobuf:"bytes,3,opt,name=message_id,json=messageId" json:"message_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *CommandSeek) Reset()         { *m = CommandSeek{} }
func (m *CommandSeek) String() string { return proto.CompactTextString(m) }
func (*CommandSeek) ProtoMessage()    {}
func (*CommandSeek) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{23}
}
func (m *CommandSeek) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandSeek) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandSeek.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandSeek) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandSeek.Merge(m, src)
}
func (m *CommandSeek) XXX_Size() int {
	return m.Size()
}
func (m *CommandSeek) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandSeek.DiscardUnknown(m)
}

var xxx_messageInfo_CommandSeek proto.InternalMessageInfo

func (m *CommandSeek) GetConsumerId() uint64 {
	if m != nil && m.ConsumerId != nil {
		return *m.ConsumerId
	}
	return 0
}

func (m *CommandSeek) GetRequestId() uint64 {
	if m != nil && m.RequestId != nil {
		return *m.RequestId
	}
	return 0
}

func (m *CommandSeek) GetMessageId() *MessageIdData {
	if m != nil {
		return m.MessageId
	}
	return nil
}

// Message sent by broker to client when a topic
// has been forcefully terminated and there are no more
// messages left to consume
type CommandReachedEndOfTopic struct {
	ConsumerId           *uint64  `protobuf:"varint,1,req,name=consumer_id,json=consumerId" json:"consumer_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandReachedEndOfTopic) Reset()         { *m = CommandReachedEndOfTopic{} }
func (m *CommandReachedEndOfTopic) String() string { return proto.CompactTextString(m) }
func (*CommandReachedEndOfTopic) ProtoMessage()    {}
func (*CommandReachedEndOfTopic) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{24}
}
func (m *CommandReachedEndOfTopic) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandReachedEndOfTopic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandReachedEndOfTopic.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandReachedEndOfTopic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandReachedEndOfTopic.Merge(m, src)
}
func (m *CommandReachedEndOfTopic) XXX_Size() int {
	return m.Size()
}
func (m *CommandReachedEndOfTopic) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandReachedEndOfTopic.DiscardUnknown(m)
}

var xxx_messageInfo_CommandReachedEndOfTopic proto.InternalMessageInfo

func (m *CommandReachedEndOfTopic) GetConsumerId() uint64 {
	if m != nil && m.ConsumerId != nil {
		return *m.ConsumerId
	}
	return 0
}

type CommandCloseProducer struct {
	ProducerId           *uint64  `protobuf:"varint,1,req,name=producer_id,json=producerId" json:"producer_id,omitempty"`
	RequestId            *uint64  `protobuf:"varint,2,req,name=request_id,json=requestId" json:"request_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandCloseProducer) Reset()         { *m = CommandCloseProducer{} }
func (m *CommandCloseProducer) String() string { return proto.CompactTextString(m) }
func (*CommandCloseProducer) ProtoMessage()    {}
func (*CommandCloseProducer) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{25}
}
func (m *CommandCloseProducer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandCloseProducer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandCloseProducer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandCloseProducer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandCloseProducer.Merge(m, src)
}
func (m *CommandCloseProducer) XXX_Size() int {
	return m.Size()
}
func (m *CommandCloseProducer) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandCloseProducer.DiscardUnknown(m)
}

var xxx_messageInfo_CommandCloseProducer proto.InternalMessageInfo

func (m *CommandCloseProducer) GetProducerId() uint64 {
	if m != nil && m.ProducerId != nil {
		return *m.ProducerId
	}
	return 0
}

func (m *CommandCloseProducer) GetRequestId() uint64 {
	if m != nil && m.RequestId != nil {
		return *m.RequestId
	}
	return 0
}

type CommandCloseConsumer struct {
	ConsumerId           *uint64  `protobuf:"varint,1,req,name=consumer_id,json=consumerId" json:"consumer_id,omitempty"`
	RequestId            *uint64  `protobuf:"varint,2,req,name=request_id,json=requestId" json:"request_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandCloseConsumer) Reset()         { *m = CommandCloseConsumer{} }
func (m *CommandCloseConsumer) String() string { return proto.CompactTextString(m) }
func (*CommandCloseConsumer) ProtoMessage()    {}
func (*CommandCloseConsumer) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{26}
}
func (m *CommandCloseConsumer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandCloseConsumer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandCloseConsumer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandCloseConsumer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandCloseConsumer.Merge(m, src)
}
func (m *CommandCloseConsumer) XXX_Size() int {
	return m.Size()
}
func (m *CommandCloseConsumer) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandCloseConsumer.DiscardUnknown(m)
}

var xxx_messageInfo_CommandCloseConsumer proto.InternalMessageInfo

func (m *CommandCloseConsumer) GetConsumerId() uint64 {
	if m != nil && m.ConsumerId != nil {
		return *m.ConsumerId
	}
	return 0
}

func (m *CommandCloseConsumer) GetRequestId() uint64 {
	if m != nil && m.RequestId != nil {
		return *m.RequestId
	}
	return 0
}

type CommandRedeliverUnacknowledgedMessages struct {
	ConsumerId           *uint64          `protobuf:"varint,1,req,name=consumer_id,json=consumerId" json:"consumer_id,omitempty"`
	MessageIds           []*MessageIdData `protobuf:"bytes,2,rep,name=message_ids,json=messageIds" json:"message_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *CommandRedeliverUnacknowledgedMessages) Reset() {
	*m = CommandRedeliverUnacknowledgedMessages{}
}
func (m *CommandRedeliverUnacknowledgedMessages) String() string { return proto.CompactTextString(m) }
func (*CommandRedeliverUnacknowledgedMessages) ProtoMessage()    {}
func (*CommandRedeliverUnacknowledgedMessages) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{27}
}
func (m *CommandRedeliverUnacknowledgedMessages) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandRedeliverUnacknowledgedMessages) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandRedeliverUnacknowledgedMessages.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandRedeliverUnacknowledgedMessages) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandRedeliverUnacknowledgedMessages.Merge(m, src)
}
func (m *CommandRedeliverUnacknowledgedMessages) XXX_Size() int {
	return m.Size()
}
func (m *CommandRedeliverUnacknowledgedMessages) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandRedeliverUnacknowledgedMessages.DiscardUnknown(m)
}

var xxx_messageInfo_CommandRedeliverUnacknowledgedMessages proto.InternalMessageInfo

func (m *CommandRedeliverUnacknowledgedMessages) GetConsumerId() uint64 {
	if m != nil && m.ConsumerId != nil {
		return *m.ConsumerId
	}
	return 0
}

func (m *CommandRedeliverUnacknowledgedMessages) GetMessageIds() []*MessageIdData {
	if m != nil {
		return m.MessageIds
	}
	return nil
}

type CommandSuccess struct {
	RequestId            *uint64  `protobuf:"varint,1,req,name=request_id,json=requestId" json:"request_id,omitempty"`
	Schema               *Schema  `protobuf:"bytes,2,opt,name=schema" json:"schema,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandSuccess) Reset()         { *m = CommandSuccess{} }
func (m *CommandSuccess) String() string { return proto.CompactTextString(m) }
func (*CommandSuccess) ProtoMessage()    {}
func (*CommandSuccess) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{28}
}
func (m *CommandSuccess) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandSuccess) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandSuccess.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandSuccess) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandSuccess.Merge(m, src)
}
func (m *CommandSuccess) XXX_Size() int {
	return m.Size()
}
func (m *CommandSuccess) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandSuccess.DiscardUnknown(m)
}

var xxx_messageInfo_CommandSuccess proto.InternalMessageInfo

func (m *CommandSuccess) GetRequestId() uint64 {
	if m != nil && m.RequestId != nil {
		return *m.RequestId
	}
	return 0
}

func (m *CommandSuccess) GetSchema() *Schema {
	if m != nil {
		return m.Schema
	}
	return nil
}

/// Response from CommandProducer
type CommandProducerSuccess struct {
	RequestId    *uint64 `protobuf:"varint,1,req,name=request_id,json=requestId" json:"request_id,omitempty"`
	ProducerName *string `protobuf:"bytes,2,req,name=producer_name,json=producerName" json:"producer_name,omitempty"`
	// The last sequence id that was stored by this producer in the previous session
	// This will only be meaningful if deduplication has been enabled.
	LastSequenceId       *int64   `protobuf:"varint,3,opt,name=last_sequence_id,json=lastSequenceId,def=-1" json:"last_sequence_id,omitempty"`
	SchemaVersion        []byte   `protobuf:"bytes,4,opt,name=schema_version,json=schemaVersion" json:"schema_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandProducerSuccess) Reset()         { *m = CommandProducerSuccess{} }
func (m *CommandProducerSuccess) String() string { return proto.CompactTextString(m) }
func (*CommandProducerSuccess) ProtoMessage()    {}
func (*CommandProducerSuccess) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{29}
}
func (m *CommandProducerSuccess) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandProducerSuccess) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandProducerSuccess.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandProducerSuccess) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandProducerSuccess.Merge(m, src)
}
func (m *CommandProducerSuccess) XXX_Size() int {
	return m.Size()
}
func (m *CommandProducerSuccess) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandProducerSuccess.DiscardUnknown(m)
}

var xxx_messageInfo_CommandProducerSuccess proto.InternalMessageInfo

const Default_CommandProducerSuccess_LastSequenceId int64 = -1

func (m *CommandProducerSuccess) GetRequestId() uint64 {
	if m != nil && m.RequestId != nil {
		return *m.RequestId
	}
	return 0
}

func (m *CommandProducerSuccess) GetProducerName() string {
	if m != nil && m.ProducerName != nil {
		return *m.ProducerName
	}
	return ""
}

func (m *CommandProducerSuccess) GetLastSequenceId() int64 {
	if m != nil && m.LastSequenceId != nil {
		return *m.LastSequenceId
	}
	return Default_CommandProducerSuccess_LastSequenceId
}

func (m *CommandProducerSuccess) GetSchemaVersion() []byte {
	if m != nil {
		return m.SchemaVersion
	}
	return nil
}

type CommandError struct {
	RequestId            *uint64      `protobuf:"varint,1,req,name=request_id,json=requestId" json:"request_id,omitempty"`
	Error                *ServerError `protobuf:"varint,2,req,name=error,enum=pulsar.proto.ServerError" json:"error,omitempty"`
	Message              *string      `protobuf:"bytes,3,req,name=message" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *CommandError) Reset()         { *m = CommandError{} }
func (m *CommandError) String() string { return proto.CompactTextString(m) }
func (*CommandError) ProtoMessage()    {}
func (*CommandError) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{30}
}
func (m *CommandError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandError.Merge(m, src)
}
func (m *CommandError) XXX_Size() int {
	return m.Size()
}
func (m *CommandError) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandError.DiscardUnknown(m)
}

var xxx_messageInfo_CommandError proto.InternalMessageInfo

func (m *CommandError) GetRequestId() uint64 {
	if m != nil && m.RequestId != nil {
		return *m.RequestId
	}
	return 0
}

func (m *CommandError) GetError() ServerError {
	if m != nil && m.Error != nil {
		return *m.Error
	}
	return ServerError_UnknownError
}

func (m *CommandError) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

// Commands to probe the state of connection.
// When either client or broker doesn't receive commands for certain
// amount of time, they will send a Ping probe.
type CommandPing struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandPing) Reset()         { *m = CommandPing{} }
func (m *CommandPing) String() string { return proto.CompactTextString(m) }
func (*CommandPing) ProtoMessage()    {}
func (*CommandPing) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{31}
}
func (m *CommandPing) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandPing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandPing.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandPing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandPing.Merge(m, src)
}
func (m *CommandPing) XXX_Size() int {
	return m.Size()
}
func (m *CommandPing) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandPing.DiscardUnknown(m)
}

var xxx_messageInfo_CommandPing proto.InternalMessageInfo

type CommandPong struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandPong) Reset()         { *m = CommandPong{} }
func (m *CommandPong) String() string { return proto.CompactTextString(m) }
func (*CommandPong) ProtoMessage()    {}
func (*CommandPong) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{32}
}
func (m *CommandPong) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandPong) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandPong.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandPong) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandPong.Merge(m, src)
}
func (m *CommandPong) XXX_Size() int {
	return m.Size()
}
func (m *CommandPong) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandPong.DiscardUnknown(m)
}

var xxx_messageInfo_CommandPong proto.InternalMessageInfo

type CommandConsumerStats struct {
	RequestId *uint64 `protobuf:"varint,1,req,name=request_id,json=requestId" json:"request_id,omitempty"`
	// required string topic_name         = 2;
	// required string subscription_name  = 3;
	ConsumerId           *uint64  `protobuf:"varint,4,req,name=consumer_id,json=consumerId" json:"consumer_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandConsumerStats) Reset()         { *m = CommandConsumerStats{} }
func (m *CommandConsumerStats) String() string { return proto.CompactTextString(m) }
func (*CommandConsumerStats) ProtoMessage()    {}
func (*CommandConsumerStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{33}
}
func (m *CommandConsumerStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandConsumerStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandConsumerStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandConsumerStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandConsumerStats.Merge(m, src)
}
func (m *CommandConsumerStats) XXX_Size() int {
	return m.Size()
}
func (m *CommandConsumerStats) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandConsumerStats.DiscardUnknown(m)
}

var xxx_messageInfo_CommandConsumerStats proto.InternalMessageInfo

func (m *CommandConsumerStats) GetRequestId() uint64 {
	if m != nil && m.RequestId != nil {
		return *m.RequestId
	}
	return 0
}

func (m *CommandConsumerStats) GetConsumerId() uint64 {
	if m != nil && m.ConsumerId != nil {
		return *m.ConsumerId
	}
	return 0
}

type CommandConsumerStatsResponse struct {
	RequestId    *uint64      `protobuf:"varint,1,req,name=request_id,json=requestId" json:"request_id,omitempty"`
	ErrorCode    *ServerError `protobuf:"varint,2,opt,name=error_code,json=errorCode,enum=pulsar.proto.ServerError" json:"error_code,omitempty"`
	ErrorMessage *string      `protobuf:"bytes,3,opt,name=error_message,json=errorMessage" json:"error_message,omitempty"`
	/// Total rate of messages delivered to the consumer. msg/s
	MsgRateOut *float64 `protobuf:"fixed64,4,opt,name=msgRateOut" json:"msgRateOut,omitempty"`
	/// Total throughput delivered to the consumer. bytes/s
	MsgThroughputOut *float64 `protobuf:"fixed64,5,opt,name=msgThroughputOut" json:"msgThroughputOut,omitempty"`
	/// Total rate of messages redelivered by this consumer. msg/s
	MsgRateRedeliver *float64 `protobuf:"fixed64,6,opt,name=msgRateRedeliver" json:"msgRateRedeliver,omitempty"`
	/// Name of the consumer
	ConsumerName *string `protobuf:"bytes,7,opt,name=consumerName" json:"consumerName,omitempty"`
	/// Number of available message permits for the consumer
	AvailablePermits *uint64 `protobuf:"varint,8,opt,name=availablePermits" json:"availablePermits,omitempty"`
	/// Number of unacknowledged messages for the consumer
	UnackedMessages *uint64 `protobuf:"varint,9,opt,name=unackedMessages" json:"unackedMessages,omitempty"`
	/// Flag to verify if consumer is blocked due to reaching threshold of unacked messages
	BlockedConsumerOnUnackedMsgs *bool `protobuf:"varint,10,opt,name=blockedConsumerOnUnackedMsgs" json:"blockedConsumerOnUnackedMsgs,omitempty"`
	/// Address of this consumer
	Address *string `protobuf:"bytes,11,opt,name=address" json:"address,omitempty"`
	/// Timestamp of connection
	ConnectedSince *string `protobuf:"bytes,12,opt,name=connectedSince" json:"connectedSince,omitempty"`
	/// Whether this subscription is Exclusive or Shared or Failover
	Type *string `protobuf:"bytes,13,opt,name=type" json:"type,omitempty"`
	/// Total rate of messages expired on this subscription. msg/s
	MsgRateExpired *float64 `protobuf:"fixed64,14,opt,name=msgRateExpired" json:"msgRateExpired,omitempty"`
	/// Number of messages in the subscription backlog
	MsgBacklog           *uint64  `protobuf:"varint,15,opt,name=msgBacklog" json:"msgBacklog,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandConsumerStatsResponse) Reset()         { *m = CommandConsumerStatsResponse{} }
func (m *CommandConsumerStatsResponse) String() string { return proto.CompactTextString(m) }
func (*CommandConsumerStatsResponse) ProtoMessage()    {}
func (*CommandConsumerStatsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{34}
}
func (m *CommandConsumerStatsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandConsumerStatsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandConsumerStatsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandConsumerStatsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandConsumerStatsResponse.Merge(m, src)
}
func (m *CommandConsumerStatsResponse) XXX_Size() int {
	return m.Size()
}
func (m *CommandConsumerStatsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandConsumerStatsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CommandConsumerStatsResponse proto.InternalMessageInfo

func (m *CommandConsumerStatsResponse) GetRequestId() uint64 {
	if m != nil && m.RequestId != nil {
		return *m.RequestId
	}
	return 0
}

func (m *CommandConsumerStatsResponse) GetErrorCode() ServerError {
	if m != nil && m.ErrorCode != nil {
		return *m.ErrorCode
	}
	return ServerError_UnknownError
}

func (m *CommandConsumerStatsResponse) GetErrorMessage() string {
	if m != nil && m.ErrorMessage != nil {
		return *m.ErrorMessage
	}
	return ""
}

func (m *CommandConsumerStatsResponse) GetMsgRateOut() float64 {
	if m != nil && m.MsgRateOut != nil {
		return *m.MsgRateOut
	}
	return 0
}

func (m *CommandConsumerStatsResponse) GetMsgThroughputOut() float64 {
	if m != nil && m.MsgThroughputOut != nil {
		return *m.MsgThroughputOut
	}
	return 0
}

func (m *CommandConsumerStatsResponse) GetMsgRateRedeliver() float64 {
	if m != nil && m.MsgRateRedeliver != nil {
		return *m.MsgRateRedeliver
	}
	return 0
}

func (m *CommandConsumerStatsResponse) GetConsumerName() string {
	if m != nil && m.ConsumerName != nil {
		return *m.ConsumerName
	}
	return ""
}

func (m *CommandConsumerStatsResponse) GetAvailablePermits() uint64 {
	if m != nil && m.AvailablePermits != nil {
		return *m.AvailablePermits
	}
	return 0
}

func (m *CommandConsumerStatsResponse) GetUnackedMessages() uint64 {
	if m != nil && m.UnackedMessages != nil {
		return *m.UnackedMessages
	}
	return 0
}

func (m *CommandConsumerStatsResponse) GetBlockedConsumerOnUnackedMsgs() bool {
	if m != nil && m.BlockedConsumerOnUnackedMsgs != nil {
		return *m.BlockedConsumerOnUnackedMsgs
	}
	return false
}

func (m *CommandConsumerStatsResponse) GetAddress() string {
	if m != nil && m.Address != nil {
		return *m.Address
	}
	return ""
}

func (m *CommandConsumerStatsResponse) GetConnectedSince() string {
	if m != nil && m.ConnectedSince != nil {
		return *m.ConnectedSince
	}
	return ""
}

func (m *CommandConsumerStatsResponse) GetType() string {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ""
}

func (m *CommandConsumerStatsResponse) GetMsgRateExpired() float64 {
	if m != nil && m.MsgRateExpired != nil {
		return *m.MsgRateExpired
	}
	return 0
}

func (m *CommandConsumerStatsResponse) GetMsgBacklog() uint64 {
	if m != nil && m.MsgBacklog != nil {
		return *m.MsgBacklog
	}
	return 0
}

type CommandGetLastMessageId struct {
	ConsumerId           *uint64  `protobuf:"varint,1,req,name=consumer_id,json=consumerId" json:"consumer_id,omitempty"`
	RequestId            *uint64  `protobuf:"varint,2,req,name=request_id,json=requestId" json:"request_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandGetLastMessageId) Reset()         { *m = CommandGetLastMessageId{} }
func (m *CommandGetLastMessageId) String() string { return proto.CompactTextString(m) }
func (*CommandGetLastMessageId) ProtoMessage()    {}
func (*CommandGetLastMessageId) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{35}
}
func (m *CommandGetLastMessageId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandGetLastMessageId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandGetLastMessageId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandGetLastMessageId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandGetLastMessageId.Merge(m, src)
}
func (m *CommandGetLastMessageId) XXX_Size() int {
	return m.Size()
}
func (m *CommandGetLastMessageId) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandGetLastMessageId.DiscardUnknown(m)
}

var xxx_messageInfo_CommandGetLastMessageId proto.InternalMessageInfo

func (m *CommandGetLastMessageId) GetConsumerId() uint64 {
	if m != nil && m.ConsumerId != nil {
		return *m.ConsumerId
	}
	return 0
}

func (m *CommandGetLastMessageId) GetRequestId() uint64 {
	if m != nil && m.RequestId != nil {
		return *m.RequestId
	}
	return 0
}

type CommandGetLastMessageIdResponse struct {
	LastMessageId        *MessageIdData `protobuf:"bytes,1,req,name=last_message_id,json=lastMessageId" json:"last_message_id,omitempty"`
	RequestId            *uint64        `protobuf:"varint,2,req,name=request_id,json=requestId" json:"request_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *CommandGetLastMessageIdResponse) Reset()         { *m = CommandGetLastMessageIdResponse{} }
func (m *CommandGetLastMessageIdResponse) String() string { return proto.CompactTextString(m) }
func (*CommandGetLastMessageIdResponse) ProtoMessage()    {}
func (*CommandGetLastMessageIdResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{36}
}
func (m *CommandGetLastMessageIdResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandGetLastMessageIdResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandGetLastMessageIdResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandGetLastMessageIdResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandGetLastMessageIdResponse.Merge(m, src)
}
func (m *CommandGetLastMessageIdResponse) XXX_Size() int {
	return m.Size()
}
func (m *CommandGetLastMessageIdResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandGetLastMessageIdResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CommandGetLastMessageIdResponse proto.InternalMessageInfo

func (m *CommandGetLastMessageIdResponse) GetLastMessageId() *MessageIdData {
	if m != nil {
		return m.LastMessageId
	}
	return nil
}

func (m *CommandGetLastMessageIdResponse) GetRequestId() uint64 {
	if m != nil && m.RequestId != nil {
		return *m.RequestId
	}
	return 0
}

type CommandGetTopicsOfNamespace struct {
	RequestId            *uint64                           `protobuf:"varint,1,req,name=request_id,json=requestId" json:"request_id,omitempty"`
	Namespace            *string                           `protobuf:"bytes,2,req,name=namespace" json:"namespace,omitempty"`
	Mode                 *CommandGetTopicsOfNamespace_Mode `protobuf:"varint,3,opt,name=mode,enum=pulsar.proto.CommandGetTopicsOfNamespace_Mode,def=0" json:"mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                          `json:"-"`
	XXX_unrecognized     []byte                            `json:"-"`
	XXX_sizecache        int32                             `json:"-"`
}

func (m *CommandGetTopicsOfNamespace) Reset()         { *m = CommandGetTopicsOfNamespace{} }
func (m *CommandGetTopicsOfNamespace) String() string { return proto.CompactTextString(m) }
func (*CommandGetTopicsOfNamespace) ProtoMessage()    {}
func (*CommandGetTopicsOfNamespace) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{37}
}
func (m *CommandGetTopicsOfNamespace) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandGetTopicsOfNamespace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandGetTopicsOfNamespace.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandGetTopicsOfNamespace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandGetTopicsOfNamespace.Merge(m, src)
}
func (m *CommandGetTopicsOfNamespace) XXX_Size() int {
	return m.Size()
}
func (m *CommandGetTopicsOfNamespace) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandGetTopicsOfNamespace.DiscardUnknown(m)
}

var xxx_messageInfo_CommandGetTopicsOfNamespace proto.InternalMessageInfo

const Default_CommandGetTopicsOfNamespace_Mode CommandGetTopicsOfNamespace_Mode = CommandGetTopicsOfNamespace_PERSISTENT

func (m *CommandGetTopicsOfNamespace) GetRequestId() uint64 {
	if m != nil && m.RequestId != nil {
		return *m.RequestId
	}
	return 0
}

func (m *CommandGetTopicsOfNamespace) GetNamespace() string {
	if m != nil && m.Namespace != nil {
		return *m.Namespace
	}
	return ""
}

func (m *CommandGetTopicsOfNamespace) GetMode() CommandGetTopicsOfNamespace_Mode {
	if m != nil && m.Mode != nil {
		return *m.Mode
	}
	return Default_CommandGetTopicsOfNamespace_Mode
}

type CommandGetTopicsOfNamespaceResponse struct {
	RequestId            *uint64  `protobuf:"varint,1,req,name=request_id,json=requestId" json:"request_id,omitempty"`
	Topics               []string `protobuf:"bytes,2,rep,name=topics" json:"topics,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandGetTopicsOfNamespaceResponse) Reset()         { *m = CommandGetTopicsOfNamespaceResponse{} }
func (m *CommandGetTopicsOfNamespaceResponse) String() string { return proto.CompactTextString(m) }
func (*CommandGetTopicsOfNamespaceResponse) ProtoMessage()    {}
func (*CommandGetTopicsOfNamespaceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{38}
}
func (m *CommandGetTopicsOfNamespaceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandGetTopicsOfNamespaceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandGetTopicsOfNamespaceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandGetTopicsOfNamespaceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandGetTopicsOfNamespaceResponse.Merge(m, src)
}
func (m *CommandGetTopicsOfNamespaceResponse) XXX_Size() int {
	return m.Size()
}
func (m *CommandGetTopicsOfNamespaceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandGetTopicsOfNamespaceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CommandGetTopicsOfNamespaceResponse proto.InternalMessageInfo

func (m *CommandGetTopicsOfNamespaceResponse) GetRequestId() uint64 {
	if m != nil && m.RequestId != nil {
		return *m.RequestId
	}
	return 0
}

func (m *CommandGetTopicsOfNamespaceResponse) GetTopics() []string {
	if m != nil {
		return m.Topics
	}
	return nil
}

type CommandGetSchema struct {
	RequestId            *uint64  `protobuf:"varint,1,req,name=request_id,json=requestId" json:"request_id,omitempty"`
	Topic                *string  `protobuf:"bytes,2,req,name=topic" json:"topic,omitempty"`
	SchemaVersion        []byte   `protobuf:"bytes,3,opt,name=schema_version,json=schemaVersion" json:"schema_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandGetSchema) Reset()         { *m = CommandGetSchema{} }
func (m *CommandGetSchema) String() string { return proto.CompactTextString(m) }
func (*CommandGetSchema) ProtoMessage()    {}
func (*CommandGetSchema) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{39}
}
func (m *CommandGetSchema) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandGetSchema) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandGetSchema.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandGetSchema) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandGetSchema.Merge(m, src)
}
func (m *CommandGetSchema) XXX_Size() int {
	return m.Size()
}
func (m *CommandGetSchema) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandGetSchema.DiscardUnknown(m)
}

var xxx_messageInfo_CommandGetSchema proto.InternalMessageInfo

func (m *CommandGetSchema) GetRequestId() uint64 {
	if m != nil && m.RequestId != nil {
		return *m.RequestId
	}
	return 0
}

func (m *CommandGetSchema) GetTopic() string {
	if m != nil && m.Topic != nil {
		return *m.Topic
	}
	return ""
}

func (m *CommandGetSchema) GetSchemaVersion() []byte {
	if m != nil {
		return m.SchemaVersion
	}
	return nil
}

type CommandGetSchemaResponse struct {
	RequestId            *uint64      `protobuf:"varint,1,req,name=request_id,json=requestId" json:"request_id,omitempty"`
	ErrorCode            *ServerError `protobuf:"varint,2,opt,name=error_code,json=errorCode,enum=pulsar.proto.ServerError" json:"error_code,omitempty"`
	ErrorMessage         *string      `protobuf:"bytes,3,opt,name=error_message,json=errorMessage" json:"error_message,omitempty"`
	Schema               *Schema      `protobuf:"bytes,4,opt,name=schema" json:"schema,omitempty"`
	SchemaVersion        []byte       `protobuf:"bytes,5,opt,name=schema_version,json=schemaVersion" json:"schema_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *CommandGetSchemaResponse) Reset()         { *m = CommandGetSchemaResponse{} }
func (m *CommandGetSchemaResponse) String() string { return proto.CompactTextString(m) }
func (*CommandGetSchemaResponse) ProtoMessage()    {}
func (*CommandGetSchemaResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{40}
}
func (m *CommandGetSchemaResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandGetSchemaResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandGetSchemaResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandGetSchemaResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandGetSchemaResponse.Merge(m, src)
}
func (m *CommandGetSchemaResponse) XXX_Size() int {
	return m.Size()
}
func (m *CommandGetSchemaResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandGetSchemaResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CommandGetSchemaResponse proto.InternalMessageInfo

func (m *CommandGetSchemaResponse) GetRequestId() uint64 {
	if m != nil && m.RequestId != nil {
		return *m.RequestId
	}
	return 0
}

func (m *CommandGetSchemaResponse) GetErrorCode() ServerError {
	if m != nil && m.ErrorCode != nil {
		return *m.ErrorCode
	}
	return ServerError_UnknownError
}

func (m *CommandGetSchemaResponse) GetErrorMessage() string {
	if m != nil && m.ErrorMessage != nil {
		return *m.ErrorMessage
	}
	return ""
}

func (m *CommandGetSchemaResponse) GetSchema() *Schema {
	if m != nil {
		return m.Schema
	}
	return nil
}

func (m *CommandGetSchemaResponse) GetSchemaVersion() []byte {
	if m != nil {
		return m.SchemaVersion
	}
	return nil
}

type BaseCommand struct {
	Type                            *BaseCommand_Type                        `protobuf:"varint,1,req,name=type,enum=pulsar.proto.BaseCommand_Type" json:"type,omitempty"`
	Connect                         *CommandConnect                          `protobuf:"bytes,2,opt,name=connect" json:"connect,omitempty"`
	Connected                       *CommandConnected                        `protobuf:"bytes,3,opt,name=connected" json:"connected,omitempty"`
	Subscribe                       *CommandSubscribe                        `protobuf:"bytes,4,opt,name=subscribe" json:"subscribe,omitempty"`
	Producer                        *CommandProducer                         `protobuf:"bytes,5,opt,name=producer" json:"producer,omitempty"`
	Send                            *CommandSend                             `protobuf:"bytes,6,opt,name=send" json:"send,omitempty"`
	SendReceipt                     *CommandSendReceipt                      `protobuf:"bytes,7,opt,name=send_receipt,json=sendReceipt" json:"send_receipt,omitempty"`
	SendError                       *CommandSendError                        `protobuf:"bytes,8,opt,name=send_error,json=sendError" json:"send_error,omitempty"`
	Message                         *CommandMessage                          `protobuf:"bytes,9,opt,name=message" json:"message,omitempty"`
	Ack                             *CommandAck                              `protobuf:"bytes,10,opt,name=ack" json:"ack,omitempty"`
	Flow                            *CommandFlow                             `protobuf:"bytes,11,opt,name=flow" json:"flow,omitempty"`
	Unsubscribe                     *CommandUnsubscribe                      `protobuf:"bytes,12,opt,name=unsubscribe" json:"unsubscribe,omitempty"`
	Success                         *CommandSuccess                          `protobuf:"bytes,13,opt,name=success" json:"success,omitempty"`
	Error                           *CommandError                            `protobuf:"bytes,14,opt,name=error" json:"error,omitempty"`
	CloseProducer                   *CommandCloseProducer                    `protobuf:"bytes,15,opt,name=close_producer,json=closeProducer" json:"close_producer,omitempty"`
	CloseConsumer                   *CommandCloseConsumer                    `protobuf:"bytes,16,opt,name=close_consumer,json=closeConsumer" json:"close_consumer,omitempty"`
	ProducerSuccess                 *CommandProducerSuccess                  `protobuf:"bytes,17,opt,name=producer_success,json=producerSuccess" json:"producer_success,omitempty"`
	Ping                            *CommandPing                             `protobuf:"bytes,18,opt,name=ping" json:"ping,omitempty"`
	Pong                            *CommandPong                             `protobuf:"bytes,19,opt,name=pong" json:"pong,omitempty"`
	RedeliverUnacknowledgedMessages *CommandRedeliverUnacknowledgedMessages  `protobuf:"bytes,20,opt,name=redeliverUnacknowledgedMessages" json:"redeliverUnacknowledgedMessages,omitempty"`
	PartitionMetadata               *CommandPartitionedTopicMetadata         `protobuf:"bytes,21,opt,name=partitionMetadata" json:"partitionMetadata,omitempty"`
	PartitionMetadataResponse       *CommandPartitionedTopicMetadataResponse `protobuf:"bytes,22,opt,name=partitionMetadataResponse" json:"partitionMetadataResponse,omitempty"`
	LookupTopic                     *CommandLookupTopic                      `protobuf:"bytes,23,opt,name=lookupTopic" json:"lookupTopic,omitempty"`
	LookupTopicResponse             *CommandLookupTopicResponse              `protobuf:"bytes,24,opt,name=lookupTopicResponse" json:"lookupTopicResponse,omitempty"`
	ConsumerStats                   *CommandConsumerStats                    `protobuf:"bytes,25,opt,name=consumerStats" json:"consumerStats,omitempty"`
	ConsumerStatsResponse           *CommandConsumerStatsResponse            `protobuf:"bytes,26,opt,name=consumerStatsResponse" json:"consumerStatsResponse,omitempty"`
	ReachedEndOfTopic               *CommandReachedEndOfTopic                `protobuf:"bytes,27,opt,name=reachedEndOfTopic" json:"reachedEndOfTopic,omitempty"`
	Seek                            *CommandSeek                             `protobuf:"bytes,28,opt,name=seek" json:"seek,omitempty"`
	GetLastMessageId                *CommandGetLastMessageId                 `protobuf:"bytes,29,opt,name=getLastMessageId" json:"getLastMessageId,omitempty"`
	GetLastMessageIdResponse        *CommandGetLastMessageIdResponse         `protobuf:"bytes,30,opt,name=getLastMessageIdResponse" json:"getLastMessageIdResponse,omitempty"`
	ActiveConsumerChange            *CommandActiveConsumerChange             `protobuf:"bytes,31,opt,name=active_consumer_change,json=activeConsumerChange" json:"active_consumer_change,omitempty"`
	GetTopicsOfNamespace            *CommandGetTopicsOfNamespace             `protobuf:"bytes,32,opt,name=getTopicsOfNamespace" json:"getTopicsOfNamespace,omitempty"`
	GetTopicsOfNamespaceResponse    *CommandGetTopicsOfNamespaceResponse     `protobuf:"bytes,33,opt,name=getTopicsOfNamespaceResponse" json:"getTopicsOfNamespaceResponse,omitempty"`
	GetSchema                       *CommandGetSchema                        `protobuf:"bytes,34,opt,name=getSchema" json:"getSchema,omitempty"`
	GetSchemaResponse               *CommandGetSchemaResponse                `protobuf:"bytes,35,opt,name=getSchemaResponse" json:"getSchemaResponse,omitempty"`
	XXX_NoUnkeyedLiteral            struct{}                                 `json:"-"`
	XXX_unrecognized                []byte                                   `json:"-"`
	XXX_sizecache                   int32                                    `json:"-"`
}

func (m *BaseCommand) Reset()         { *m = BaseCommand{} }
func (m *BaseCommand) String() string { return proto.CompactTextString(m) }
func (*BaseCommand) ProtoMessage()    {}
func (*BaseCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_ffc7a491d9398c1a, []int{41}
}
func (m *BaseCommand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BaseCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BaseCommand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BaseCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BaseCommand.Merge(m, src)
}
func (m *BaseCommand) XXX_Size() int {
	return m.Size()
}
func (m *BaseCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_BaseCommand.DiscardUnknown(m)
}

var xxx_messageInfo_BaseCommand proto.InternalMessageInfo

func (m *BaseCommand) GetType() BaseCommand_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return BaseCommand_CONNECT
}

func (m *BaseCommand) GetConnect() *CommandConnect {
	if m != nil {
		return m.Connect
	}
	return nil
}

func (m *BaseCommand) GetConnected() *CommandConnected {
	if m != nil {
		return m.Connected
	}
	return nil
}

func (m *BaseCommand) GetSubscribe() *CommandSubscribe {
	if m != nil {
		return m.Subscribe
	}
	return nil
}

func (m *BaseCommand) GetProducer() *CommandProducer {
	if m != nil {
		return m.Producer
	}
	return nil
}

func (m *BaseCommand) GetSend() *CommandSend {
	if m != nil {
		return m.Send
	}
	return nil
}

func (m *BaseCommand) GetSendReceipt() *CommandSendReceipt {
	if m != nil {
		return m.SendReceipt
	}
	return nil
}

func (m *BaseCommand) GetSendError() *CommandSendError {
	if m != nil {
		return m.SendError
	}
	return nil
}

func (m *BaseCommand) GetMessage() *CommandMessage {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *BaseCommand) GetAck() *CommandAck {
	if m != nil {
		return m.Ack
	}
	return nil
}

func (m *BaseCommand) GetFlow() *CommandFlow {
	if m != nil {
		return m.Flow
	}
	return nil
}

func (m *BaseCommand) GetUnsubscribe() *CommandUnsubscribe {
	if m != nil {
		return m.Unsubscribe
	}
	return nil
}

func (m *BaseCommand) GetSuccess() *CommandSuccess {
	if m != nil {
		return m.Success
	}
	return nil
}

func (m *BaseCommand) GetError() *CommandError {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *BaseCommand) GetCloseProducer() *CommandCloseProducer {
	if m != nil {
		return m.CloseProducer
	}
	return nil
}

func (m *BaseCommand) GetCloseConsumer() *CommandCloseConsumer {
	if m != nil {
		return m.CloseConsumer
	}
	return nil
}

func (m *BaseCommand) GetProducerSuccess() *CommandProducerSuccess {
	if m != nil {
		return m.ProducerSuccess
	}
	return nil
}

func (m *BaseCommand) GetPing() *CommandPing {
	if m != nil {
		return m.Ping
	}
	return nil
}

func (m *BaseCommand) GetPong() *CommandPong {
	if m != nil {
		return m.Pong
	}
	return nil
}

func (m *BaseCommand) GetRedeliverUnacknowledgedMessages() *CommandRedeliverUnacknowledgedMessages {
	if m != nil {
		return m.RedeliverUnacknowledgedMessages
	}
	return nil
}

func (m *BaseCommand) GetPartitionMetadata() *CommandPartitionedTopicMetadata {
	if m != nil {
		return m.PartitionMetadata
	}
	return nil
}

func (m *BaseCommand) GetPartitionMetadataResponse() *CommandPartitionedTopicMetadataResponse {
	if m != nil {
		return m.PartitionMetadataResponse
	}
	return nil
}

func (m *BaseCommand) GetLookupTopic() *CommandLookupTopic {
	if m != nil {
		return m.LookupTopic
	}
	return nil
}

func (m *BaseCommand) GetLookupTopicResponse() *CommandLookupTopicResponse {
	if m != nil {
		return m.LookupTopicResponse
	}
	return nil
}

func (m *BaseCommand) GetConsumerStats() *CommandConsumerStats {
	if m != nil {
		return m.ConsumerStats
	}
	return nil
}

func (m *BaseCommand) GetConsumerStatsResponse() *CommandConsumerStatsResponse {
	if m != nil {
		return m.ConsumerStatsResponse
	}
	return nil
}

func (m *BaseCommand) GetReachedEndOfTopic() *CommandReachedEndOfTopic {
	if m != nil {
		return m.ReachedEndOfTopic
	}
	return nil
}

func (m *BaseCommand) GetSeek() *CommandSeek {
	if m != nil {
		return m.Seek
	}
	return nil
}

func (m *BaseCommand) GetGetLastMessageId() *CommandGetLastMessageId {
	if m != nil {
		return m.GetLastMessageId
	}
	return nil
}

func (m *BaseCommand) GetGetLastMessageIdResponse() *CommandGetLastMessageIdResponse {
	if m != nil {
		return m.GetLastMessageIdResponse
	}
	return nil
}

func (m *BaseCommand) GetActiveConsumerChange() *CommandActiveConsumerChange {
	if m != nil {
		return m.ActiveConsumerChange
	}
	return nil
}

func (m *BaseCommand) GetGetTopicsOfNamespace() *CommandGetTopicsOfNamespace {
	if m != nil {
		return m.GetTopicsOfNamespace
	}
	return nil
}

func (m *BaseCommand) GetGetTopicsOfNamespaceResponse() *CommandGetTopicsOfNamespaceResponse {
	if m != nil {
		return m.GetTopicsOfNamespaceResponse
	}
	return nil
}

func (m *BaseCommand) GetGetSchema() *CommandGetSchema {
	if m != nil {
		return m.GetSchema
	}
	return nil
}

func (m *BaseCommand) GetGetSchemaResponse() *CommandGetSchemaResponse {
	if m != nil {
		return m.GetSchemaResponse
	}
	return nil
}

func init() {
	proto.RegisterEnum("pulsar.proto.CompressionType", CompressionType_name, CompressionType_value)
	proto.RegisterEnum("pulsar.proto.ServerError", ServerError_name, ServerError_value)
	proto.RegisterEnum("pulsar.proto.AuthMethod", AuthMethod_name, AuthMethod_value)
	proto.RegisterEnum("pulsar.proto.ProtocolVersion", ProtocolVersion_name, ProtocolVersion_value)
	proto.RegisterEnum("pulsar.proto.Schema_Type", Schema_Type_name, Schema_Type_value)
	proto.RegisterEnum("pulsar.proto.CommandSubscribe_SubType", CommandSubscribe_SubType_name, CommandSubscribe_SubType_value)
	proto.RegisterEnum("pulsar.proto.CommandSubscribe_InitialPosition", CommandSubscribe_InitialPosition_name, CommandSubscribe_InitialPosition_value)
	proto.RegisterEnum("pulsar.proto.CommandPartitionedTopicMetadataResponse_LookupType", CommandPartitionedTopicMetadataResponse_LookupType_name, CommandPartitionedTopicMetadataResponse_LookupType_value)
	proto.RegisterEnum("pulsar.proto.CommandLookupTopicResponse_LookupType", CommandLookupTopicResponse_LookupType_name, CommandLookupTopicResponse_LookupType_value)
	proto.RegisterEnum("pulsar.proto.CommandAck_AckType", CommandAck_AckType_name, CommandAck_AckType_value)
	proto.RegisterEnum("pulsar.proto.CommandAck_ValidationError", CommandAck_ValidationError_name, CommandAck_ValidationError_value)
	proto.RegisterEnum("pulsar.proto.CommandGetTopicsOfNamespace_Mode", CommandGetTopicsOfNamespace_Mode_name, CommandGetTopicsOfNamespace_Mode_value)
	proto.RegisterEnum("pulsar.proto.BaseCommand_Type", BaseCommand_Type_name, BaseCommand_Type_value)
	proto.RegisterType((*Schema)(nil), "pulsar.proto.Schema")
	proto.RegisterType((*MessageIdData)(nil), "pulsar.proto.MessageIdData")
	proto.RegisterType((*KeyValue)(nil), "pulsar.proto.KeyValue")
	proto.RegisterType((*KeyLongValue)(nil), "pulsar.proto.KeyLongValue")
	proto.RegisterType((*EncryptionKeys)(nil), "pulsar.proto.EncryptionKeys")
	proto.RegisterType((*MessageMetadata)(nil), "pulsar.proto.MessageMetadata")
	proto.RegisterType((*SingleMessageMetadata)(nil), "pulsar.proto.SingleMessageMetadata")
	proto.RegisterType((*CommandConnect)(nil), "pulsar.proto.CommandConnect")
	proto.RegisterType((*CommandConnected)(nil), "pulsar.proto.CommandConnected")
	proto.RegisterType((*CommandSubscribe)(nil), "pulsar.proto.CommandSubscribe")
	proto.RegisterType((*CommandPartitionedTopicMetadata)(nil), "pulsar.proto.CommandPartitionedTopicMetadata")
	proto.RegisterType((*CommandPartitionedTopicMetadataResponse)(nil), "pulsar.proto.CommandPartitionedTopicMetadataResponse")
	proto.RegisterType((*CommandLookupTopic)(nil), "pulsar.proto.CommandLookupTopic")
	proto.RegisterType((*CommandLookupTopicResponse)(nil), "pulsar.proto.CommandLookupTopicResponse")
	proto.RegisterType((*CommandProducer)(nil), "pulsar.proto.CommandProducer")
	proto.RegisterType((*CommandSend)(nil), "pulsar.proto.CommandSend")
	proto.RegisterType((*CommandSendReceipt)(nil), "pulsar.proto.CommandSendReceipt")
	proto.RegisterType((*CommandSendError)(nil), "pulsar.proto.CommandSendError")
	proto.RegisterType((*CommandMessage)(nil), "pulsar.proto.CommandMessage")
	proto.RegisterType((*CommandAck)(nil), "pulsar.proto.CommandAck")
	proto.RegisterType((*CommandActiveConsumerChange)(nil), "pulsar.proto.CommandActiveConsumerChange")
	proto.RegisterType((*CommandFlow)(nil), "pulsar.proto.CommandFlow")
	proto.RegisterType((*CommandUnsubscribe)(nil), "pulsar.proto.CommandUnsubscribe")
	proto.RegisterType((*CommandSeek)(nil), "pulsar.proto.CommandSeek")
	proto.RegisterType((*CommandReachedEndOfTopic)(nil), "pulsar.proto.CommandReachedEndOfTopic")
	proto.RegisterType((*CommandCloseProducer)(nil), "pulsar.proto.CommandCloseProducer")
	proto.RegisterType((*CommandCloseConsumer)(nil), "pulsar.proto.CommandCloseConsumer")
	proto.RegisterType((*CommandRedeliverUnacknowledgedMessages)(nil), "pulsar.proto.CommandRedeliverUnacknowledgedMessages")
	proto.RegisterType((*CommandSuccess)(nil), "pulsar.proto.CommandSuccess")
	proto.RegisterType((*CommandProducerSuccess)(nil), "pulsar.proto.CommandProducerSuccess")
	proto.RegisterType((*CommandError)(nil), "pulsar.proto.CommandError")
	proto.RegisterType((*CommandPing)(nil), "pulsar.proto.CommandPing")
	proto.RegisterType((*CommandPong)(nil), "pulsar.proto.CommandPong")
	proto.RegisterType((*CommandConsumerStats)(nil), "pulsar.proto.CommandConsumerStats")
	proto.RegisterType((*CommandConsumerStatsResponse)(nil), "pulsar.proto.CommandConsumerStatsResponse")
	proto.RegisterType((*CommandGetLastMessageId)(nil), "pulsar.proto.CommandGetLastMessageId")
	proto.RegisterType((*CommandGetLastMessageIdResponse)(nil), "pulsar.proto.CommandGetLastMessageIdResponse")
	proto.RegisterType((*CommandGetTopicsOfNamespace)(nil), "pulsar.proto.CommandGetTopicsOfNamespace")
	proto.RegisterType((*CommandGetTopicsOfNamespaceResponse)(nil), "pulsar.proto.CommandGetTopicsOfNamespaceResponse")
	proto.RegisterType((*CommandGetSchema)(nil), "pulsar.proto.CommandGetSchema")
	proto.RegisterType((*CommandGetSchemaResponse)(nil), "pulsar.proto.CommandGetSchemaResponse")
	proto.RegisterType((*BaseCommand)(nil), "pulsar.proto.BaseCommand")
}

func init() { proto.RegisterFile("pulsar.proto", fileDescriptor_ffc7a491d9398c1a) }

var fileDescriptor_ffc7a491d9398c1a = []byte{
	// 4065 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x3a, 0x4d, 0x6f, 0x1b, 0x49,
	0x76, 0x6e, 0x7e, 0x48, 0xe4, 0xe3, 0x57, 0xb9, 0x2c, 0xcb, 0xed, 0x2f, 0x99, 0x6e, 0x8f, 0x67,
	0x34, 0xde, 0xb1, 0x62, 0xcb, 0x5e, 0x67, 0xc7, 0xbb, 0x09, 0x86, 0xa2, 0xda, 0x36, 0x23, 0x89,
	0xd4, 0x16, 0x29, 0x2f, 0x76, 0xb2, 0x8b, 0xde, 0x56, 0x77, 0x99, 0x6a, 0xa8, 0xd9, 0xcd, 0x74,
	0x37, 0x35, 0xd6, 0x1c, 0x72, 0x1b, 0x04, 0x01, 0x02, 0x04, 0x48, 0x2e, 0x01, 0x72, 0xc8, 0x21,
	0x08, 0x72, 0xce, 0x2d, 0x40, 0xf2, 0x03, 0x72, 0x09, 0x90, 0x6b, 0x4e, 0x09, 0x26, 0xc9, 0x31,
	0x40, 0x0e, 0x41, 0xce, 0x41, 0x55, 0x57, 0x7f, 0x91, 0x14, 0x29, 0xef, 0xcc, 0x61, 0x4f, 0xdd,
	0xfd, 0xea, 0xd5, 0xab, 0x57, 0xef, 0xbd, 0x7a, 0x5f, 0xd5, 0x50, 0x1d, 0x4f, 0x6c, 0x5f, 0xf7,
	0xb6, 0xc6, 0x9e, 0x1b, 0xb8, 0x38, 0xf3, 0xa5, 0xfc, 0xa7, 0x04, 0x2b, 0x7d, 0xe3, 0x84, 0x8e,
	0x74, 0x8c, 0xa1, 0xe0, 0xe8, 0x23, 0x2a, 0x4b, 0xcd, 0xdc, 0x66, 0x99, 0xf0, 0x77, 0x7c, 0x0f,
	0x2a, 0x3e, 0x1f, 0xd5, 0x4c, 0x3d, 0xd0, 0xe5, 0x7c, 0x33, 0xb7, 0x59, 0x25, 0x10, 0x82, 0x76,
	0xf5, 0x40, 0xc7, 0x8f, 0xa1, 0x10, 0x9c, 0x8f, 0xa9, 0x5c, 0x68, 0xe6, 0x36, 0xeb, 0xdb, 0x37,
	0xb7, 0xd2, 0xc4, 0xb7, 0x42, 0xc2, 0x5b, 0x83, 0xf3, 0x31, 0x25, 0x1c, 0x0d, 0xbf, 0x00, 0x18,
	0x7b, 0xee, 0x98, 0x7a, 0x81, 0x45, 0x7d, 0xb9, 0xd8, 0xcc, 0x6f, 0x56, 0xb6, 0xd7, 0xb3, 0x93,
	0xf6, 0xe8, 0xf9, 0x5b, 0xdd, 0x9e, 0x50, 0x92, 0xc2, 0x54, 0x7e, 0x17, 0x0a, 0x8c, 0x0a, 0x2e,
	0x41, 0xa1, 0xeb, 0x3a, 0x14, 0x5d, 0xc1, 0x00, 0x2b, 0xfd, 0xc0, 0xb3, 0x9c, 0x21, 0x92, 0x18,
	0xf4, 0xf7, 0x7c, 0xd7, 0x41, 0x39, 0x5c, 0x85, 0xd2, 0x21, 0xa3, 0x72, 0x3c, 0x79, 0x87, 0xf2,
	0x0c, 0xde, 0x3a, 0xf3, 0x5c, 0x54, 0x50, 0xfe, 0x44, 0x82, 0xda, 0x01, 0xf5, 0x7d, 0x7d, 0x48,
	0x3b, 0x26, 0x67, 0xfc, 0x16, 0x94, 0x6c, 0x6a, 0x0e, 0xa9, 0xd7, 0x31, 0xf9, 0x8e, 0x0b, 0x24,
	0xfe, 0xc6, 0x32, 0xac, 0x52, 0x27, 0xf0, 0xce, 0x3b, 0xa6, 0x9c, 0xe3, 0x43, 0xd1, 0x27, 0x6e,
	0x42, 0x79, 0xac, 0x7b, 0x81, 0x15, 0x58, 0xae, 0x23, 0xe7, 0x9b, 0xd2, 0x66, 0xf1, 0x65, 0xee,
	0xf1, 0x53, 0x92, 0x00, 0xf1, 0x03, 0xa8, 0x1c, 0xeb, 0x81, 0x71, 0xa2, 0x59, 0x8e, 0x49, 0xdf,
	0xcb, 0x85, 0x18, 0x07, 0x38, 0xb8, 0xc3, 0xa0, 0xca, 0x36, 0x94, 0xa2, 0x6d, 0x62, 0x04, 0xf9,
	0x53, 0x7a, 0x2e, 0xa4, 0xce, 0x5e, 0xf1, 0x1a, 0x14, 0xcf, 0xd8, 0x10, 0x5f, 0xbc, 0x4c, 0xc2,
	0x0f, 0xe5, 0x05, 0x54, 0xf7, 0xe8, 0xf9, 0xbe, 0xeb, 0x0c, 0x2f, 0x35, 0xaf, 0x10, 0xcd, 0xb3,
	0xa1, 0xae, 0x3a, 0x86, 0x77, 0x3e, 0x66, 0xec, 0xed, 0xd1, 0x73, 0x7f, 0xd9, 0xcc, 0xaa, 0x98,
	0x89, 0xb7, 0xa1, 0x34, 0xa2, 0x81, 0x2e, 0x34, 0xbf, 0x48, 0x55, 0x31, 0x9e, 0xf2, 0x7f, 0x45,
	0x68, 0x08, 0x41, 0x1f, 0x08, 0x18, 0x7e, 0x00, 0xb5, 0xb1, 0xe7, 0x9a, 0x13, 0x83, 0x7a, 0x5a,
	0xca, 0xc2, 0xaa, 0x11, 0xb0, 0x1b, 0x59, 0x1a, 0xfd, 0x83, 0x09, 0x75, 0x0c, 0xaa, 0x59, 0x91,
	0xdc, 0x21, 0x02, 0x75, 0x4c, 0x7c, 0x9f, 0xd9, 0xf1, 0xb1, 0x6d, 0xf9, 0x27, 0x5a, 0x60, 0x8d,
	0x28, 0xb7, 0xc5, 0x02, 0xa9, 0x08, 0xd8, 0xc0, 0x1a, 0x4d, 0x5b, 0x57, 0xe1, 0xb2, 0xd6, 0x85,
	0x3f, 0x81, 0x86, 0x47, 0xc7, 0xb6, 0x65, 0xe8, 0x01, 0x35, 0xb5, 0x77, 0x9e, 0x3b, 0x92, 0x8b,
	0x4d, 0x69, 0xb3, 0x4c, 0xea, 0x09, 0xf8, 0x95, 0xe7, 0x8e, 0xf8, 0x4e, 0x22, 0x4d, 0x6b, 0x4c,
	0x86, 0x2b, 0x1c, 0xad, 0x1a, 0x03, 0xf7, 0xe8, 0x39, 0x63, 0x34, 0x9e, 0xa6, 0x05, 0xae, 0xbc,
	0xda, 0xcc, 0x6f, 0x96, 0x49, 0x25, 0x86, 0x0d, 0x5c, 0xac, 0x42, 0xc5, 0x70, 0x47, 0x63, 0x8f,
	0xfa, 0x3e, 0x33, 0xa4, 0x52, 0x53, 0xda, 0xac, 0x6f, 0xdf, 0xcd, 0x72, 0xda, 0x4e, 0x10, 0x98,
	0xe9, 0xbf, 0x2c, 0x74, 0x7b, 0x5d, 0x95, 0xa4, 0xe7, 0xe1, 0x2d, 0xb8, 0x3a, 0x71, 0x22, 0x00,
	0x35, 0x35, 0xdf, 0xfa, 0x9a, 0xca, 0xe5, 0xa6, 0xb4, 0x59, 0x7b, 0x29, 0x3d, 0x21, 0x28, 0x3d,
	0xd6, 0xb7, 0xbe, 0xa6, 0xf8, 0x39, 0x5c, 0x77, 0x26, 0x23, 0x6d, 0x14, 0xea, 0xc7, 0xd7, 0x2c,
	0x47, 0xe3, 0x46, 0x29, 0x57, 0xb8, 0x95, 0x4a, 0x4f, 0x09, 0x76, 0x26, 0x23, 0xa1, 0x3e, 0xbf,
	0xe3, 0xec, 0xb0, 0x41, 0xdc, 0x04, 0xa0, 0x67, 0xd4, 0x09, 0x42, 0xb1, 0x57, 0x9b, 0xd2, 0x66,
	0x81, 0x91, 0x2f, 0x73, 0x20, 0x97, 0xbb, 0x0a, 0x0d, 0x1a, 0x9b, 0x18, 0x93, 0x8b, 0x2f, 0xd7,
	0xb8, 0xf0, 0xef, 0x64, 0xb7, 0x94, 0xb5, 0x43, 0x52, 0xa7, 0x59, 0xbb, 0xfc, 0x24, 0x43, 0x46,
	0xb7, 0x87, 0xae, 0x5c, 0x0f, 0xd5, 0x90, 0x80, 0x5b, 0xf6, 0xd0, 0xc5, 0x9f, 0x02, 0x4a, 0x21,
	0x8e, 0x75, 0x4f, 0x1f, 0xc9, 0x8d, 0xa6, 0xb4, 0x59, 0x25, 0x29, 0x02, 0x87, 0x0c, 0x8c, 0x1f,
	0x42, 0x5d, 0x38, 0xb0, 0x33, 0xea, 0x71, 0x61, 0x23, 0x8e, 0x58, 0x0b, 0xa1, 0x6f, 0x43, 0x20,
	0xfe, 0x02, 0x6e, 0x66, 0x14, 0xab, 0x1d, 0xbf, 0x78, 0xae, 0x51, 0xc7, 0x70, 0x4d, 0x6a, 0xca,
	0x57, 0x9b, 0xd2, 0x66, 0xe9, 0x65, 0xf1, 0x9d, 0x6e, 0xfb, 0x94, 0xac, 0xa7, 0x75, 0xbd, 0xf3,
	0xe2, 0xb9, 0x1a, 0x22, 0x29, 0x7f, 0x9b, 0x83, 0xeb, 0x7d, 0xcb, 0x19, 0xda, 0x74, 0xda, 0xfc,
	0xb3, 0x56, 0x29, 0x5d, 0xda, 0x2a, 0x67, 0x8c, 0x2d, 0x37, 0xdf, 0xd8, 0xc6, 0xfa, 0xb9, 0xed,
	0xea, 0x42, 0xfb, 0xec, 0x54, 0x14, 0x49, 0x45, 0xc0, 0xb8, 0xd6, 0x1f, 0x41, 0x8d, 0xd9, 0x81,
	0x6e, 0x30, 0xe3, 0x76, 0x27, 0x01, 0xf7, 0x49, 0xf1, 0x7e, 0xaa, 0xf1, 0x58, 0x6f, 0x12, 0x4c,
	0xe9, 0xba, 0x38, 0x47, 0xd7, 0x0b, 0x25, 0xb5, 0x72, 0x19, 0x49, 0xfd, 0x4d, 0x1e, 0xea, 0x6d,
	0x77, 0x34, 0xd2, 0x1d, 0xb3, 0xed, 0x3a, 0x0e, 0x35, 0x02, 0xa6, 0x25, 0xc3, 0xb6, 0xd8, 0xba,
	0x91, 0x96, 0x42, 0x17, 0x51, 0x0b, 0xa1, 0x91, 0x96, 0x3e, 0x87, 0x8a, 0x3e, 0x09, 0x4e, 0xb4,
	0x11, 0x0d, 0x4e, 0x5c, 0x93, 0xcb, 0xa3, 0xbe, 0x2d, 0x67, 0x45, 0xd9, 0x9a, 0x04, 0x27, 0x07,
	0x7c, 0x9c, 0x80, 0x1e, 0xbf, 0xe3, 0x4d, 0x40, 0xa9, 0xa9, 0xa1, 0x1b, 0x12, 0x67, 0x3c, 0xc1,
	0xe2, 0x8e, 0xe8, 0x36, 0x94, 0x39, 0xa6, 0x70, 0x7b, 0xcc, 0x58, 0x4a, 0x0c, 0xc0, 0xa3, 0xc6,
	0x67, 0x80, 0xf8, 0x32, 0x86, 0x6b, 0xc7, 0xac, 0x86, 0x2e, 0x5e, 0x7a, 0x42, 0x1a, 0xd1, 0x50,
	0xc4, 0xef, 0x63, 0xb8, 0x36, 0xf6, 0xdc, 0xf7, 0xe7, 0x5a, 0xe0, 0x6a, 0xc7, 0x9e, 0x7b, 0x4a,
	0x3d, 0x6d, 0xe2, 0xd9, 0xc2, 0x69, 0x20, 0x3e, 0x34, 0x70, 0x77, 0xf8, 0xc0, 0x91, 0x67, 0xe3,
	0xc7, 0x80, 0x5d, 0xcf, 0x1a, 0x5a, 0x8e, 0x6e, 0x6b, 0x63, 0xcf, 0x72, 0x0c, 0x6b, 0xac, 0xdb,
	0xf2, 0x2a, 0xc7, 0xbe, 0x1a, 0x8d, 0x1c, 0x46, 0x03, 0xf8, 0xb3, 0x14, 0x7a, 0xc2, 0x71, 0x29,
	0x24, 0x1e, 0x8d, 0xb4, 0x22, 0xce, 0x9f, 0xc0, 0x5a, 0x16, 0x5b, 0x08, 0xb1, 0xcc, 0xf1, 0x71,
	0x1a, 0x3f, 0x14, 0x86, 0x32, 0x04, 0x94, 0x55, 0x13, 0x35, 0xf9, 0x71, 0xa2, 0xde, 0x19, 0xf5,
	0xa6, 0x15, 0x15, 0x42, 0xa3, 0x8d, 0xcf, 0x13, 0x53, 0xee, 0x22, 0x31, 0x29, 0xff, 0x5c, 0x8c,
	0x57, 0xea, 0x4f, 0x8e, 0x7d, 0xc3, 0xb3, 0x8e, 0x29, 0x0b, 0x49, 0x81, 0x3b, 0xb6, 0x0c, 0xb1,
	0x40, 0xf8, 0x81, 0x15, 0xa8, 0xfa, 0x21, 0x0a, 0x3f, 0xe3, 0x22, 0x42, 0x66, 0x60, 0xf8, 0x0b,
	0x58, 0xf5, 0x27, 0xc7, 0xcc, 0x67, 0xf2, 0xd3, 0x50, 0xdf, 0xfe, 0x78, 0xc6, 0xb1, 0x66, 0x96,
	0xda, 0xea, 0x87, 0xd8, 0x24, 0x9a, 0xc6, 0x62, 0x91, 0xe1, 0x3a, 0xfe, 0x64, 0x44, 0x3d, 0x16,
	0x8b, 0x0a, 0x61, 0x2c, 0x8a, 0x40, 0x1d, 0x13, 0xdf, 0x05, 0xf0, 0x58, 0x64, 0xf2, 0x03, 0x36,
	0x5e, 0xe4, 0xe3, 0x65, 0x01, 0xe9, 0x98, 0xec, 0xe4, 0xc6, 0xf3, 0xb9, 0xa5, 0x89, 0x30, 0x11,
	0x01, 0xb9, 0x9d, 0x3d, 0x84, 0xfa, 0xd8, 0xb3, 0x5c, 0xcf, 0x0a, 0xce, 0x35, 0x9b, 0x9e, 0xd1,
	0x50, 0xd3, 0x45, 0x52, 0x8b, 0xa0, 0xfb, 0x0c, 0x88, 0x37, 0x60, 0xd5, 0x9c, 0x78, 0xfa, 0xb1,
	0x4d, 0xb9, 0x6a, 0x4b, 0x2f, 0x0b, 0x81, 0x37, 0xa1, 0x24, 0x02, 0x62, 0x15, 0x90, 0x1f, 0xe8,
	0x5e, 0x10, 0x79, 0x75, 0xc6, 0x10, 0xd3, 0x69, 0x65, 0xfb, 0x76, 0x76, 0xdb, 0x99, 0xf4, 0x87,
	0xd4, 0xf9, 0xa4, 0x18, 0x96, 0x89, 0xf5, 0x70, 0xb9, 0x58, 0xcf, 0x76, 0xe0, 0x51, 0xdd, 0xd4,
	0x62, 0x0f, 0xc2, 0xe3, 0x48, 0x89, 0xd4, 0x18, 0xb4, 0x1d, 0x01, 0xf1, 0x67, 0xb0, 0x12, 0x3a,
	0x5b, 0x1e, 0x3b, 0x2a, 0xdb, 0x6b, 0xf3, 0x92, 0x44, 0x22, 0x70, 0xf0, 0xaf, 0xa0, 0x61, 0x39,
	0x56, 0x60, 0xe9, 0xf6, 0xa1, 0xeb, 0x87, 0x79, 0x56, 0x8d, 0x9f, 0xf3, 0xad, 0x25, 0x5a, 0xec,
	0x64, 0x67, 0xbd, 0x5c, 0xd9, 0xd7, 0x03, 0xea, 0x07, 0x64, 0x9a, 0x9c, 0xb2, 0x0d, 0xab, 0x42,
	0xe3, 0xb8, 0x06, 0x65, 0xf5, 0xbd, 0x61, 0x4f, 0x7c, 0xeb, 0x2c, 0xca, 0x29, 0x4f, 0x74, 0x8f,
	0x9a, 0x48, 0x62, 0x99, 0xe4, 0x2b, 0xdd, 0xb2, 0xdd, 0x33, 0xea, 0xa1, 0x9c, 0xf2, 0x03, 0x68,
	0x4c, 0xd1, 0x67, 0xc8, 0xe1, 0x0a, 0xe8, 0x0a, 0x43, 0x56, 0x75, 0xcf, 0xb6, 0xd8, 0x97, 0xa4,
	0xfc, 0x97, 0x04, 0xf7, 0x04, 0x7b, 0x87, 0x91, 0x0b, 0xa4, 0xe6, 0x80, 0x19, 0x70, 0x1c, 0x14,
	0xe6, 0x9b, 0x77, 0xd6, 0xae, 0x72, 0xd3, 0x76, 0x35, 0xdf, 0x41, 0xe4, 0x3f, 0xcc, 0x41, 0x14,
	0x3e, 0xd0, 0x41, 0x14, 0x2f, 0x74, 0x10, 0x7f, 0x9f, 0x83, 0x4f, 0x96, 0xec, 0x93, 0x50, 0x7f,
	0xec, 0x3a, 0x3e, 0xc5, 0x1b, 0x00, 0x71, 0x38, 0x60, 0x41, 0x50, 0xda, 0xac, 0x91, 0x14, 0x64,
	0xd9, 0xce, 0x7f, 0x01, 0x25, 0x4f, 0x90, 0xe2, 0xfb, 0xad, 0x6f, 0x7f, 0x31, 0xd7, 0x1c, 0x96,
	0xf1, 0xb1, 0xb5, 0xef, 0xba, 0xa7, 0x93, 0x31, 0x3f, 0xee, 0x31, 0x45, 0xfc, 0x5b, 0x50, 0xa4,
	0x9e, 0xe7, 0x7a, 0x5c, 0x36, 0xb3, 0x55, 0x0c, 0x77, 0x6d, 0x2a, 0x43, 0x20, 0x21, 0x1e, 0x2b,
	0x10, 0xc4, 0x71, 0x13, 0xe2, 0x89, 0x3e, 0x95, 0x87, 0x00, 0xc9, 0x12, 0xb8, 0xc2, 0x4c, 0xcd,
	0x30, 0xa8, 0xef, 0x87, 0xd6, 0xc5, 0x2c, 0x8a, 0x59, 0x97, 0xf2, 0x4d, 0x0e, 0xb0, 0x60, 0x59,
	0xa0, 0x73, 0xfd, 0xff, 0x5a, 0x56, 0xf1, 0x03, 0xa8, 0x31, 0x7d, 0x31, 0x9f, 0xa1, 0x07, 0xd6,
	0x59, 0x28, 0xa0, 0x38, 0x0a, 0x67, 0xc7, 0x2e, 0x30, 0xa1, 0xc2, 0x87, 0x99, 0x50, 0xf1, 0x03,
	0x4d, 0x68, 0xe5, 0x42, 0x13, 0xfa, 0xd7, 0x3c, 0xdc, 0x9a, 0x95, 0x43, 0x6c, 0x35, 0x8f, 0x00,
	0x85, 0x71, 0x93, 0xe9, 0xc0, 0x32, 0xe8, 0x91, 0x67, 0x73, 0xdb, 0x29, 0x93, 0x19, 0x38, 0x7e,
	0x02, 0xd7, 0xa6, 0x61, 0x03, 0xdb, 0x17, 0x49, 0xd3, 0xbc, 0x21, 0xdc, 0x9b, 0x31, 0xaa, 0x67,
	0x73, 0x8d, 0x6a, 0x0e, 0x67, 0xf3, 0xed, 0x28, 0xab, 0xa8, 0xc2, 0x52, 0x45, 0x15, 0x17, 0x28,
	0x2a, 0xb6, 0xc9, 0x95, 0x0f, 0xb7, 0xc9, 0xd5, 0x8c, 0x4d, 0xf2, 0x94, 0x2d, 0x4c, 0x43, 0x4e,
	0x3c, 0x77, 0x32, 0x3c, 0xd1, 0xfc, 0x50, 0x0c, 0x3c, 0x19, 0x29, 0x65, 0x53, 0x36, 0x9e, 0x93,
	0x84, 0x68, 0x89, 0xb0, 0x94, 0x67, 0x19, 0xab, 0xae, 0x42, 0x89, 0x50, 0xd3, 0xf2, 0xa8, 0xc1,
	0x7c, 0x5f, 0x05, 0x56, 0x45, 0x7e, 0x80, 0xa4, 0x94, 0x8d, 0xe7, 0x94, 0x3f, 0xcf, 0x41, 0x23,
	0x3a, 0x96, 0xa2, 0xd2, 0xbb, 0xc0, 0xc0, 0xef, 0x41, 0x25, 0x2e, 0x10, 0x93, 0xda, 0x2f, 0x02,
	0xcd, 0xc4, 0xdb, 0xfc, 0x9c, 0x78, 0x9b, 0x2d, 0x30, 0x0b, 0x22, 0x53, 0x4e, 0x17, 0x98, 0x0f,
	0xa0, 0x2c, 0x8a, 0x03, 0x6a, 0x66, 0x25, 0x9f, 0xc0, 0x33, 0x61, 0x70, 0xe5, 0x92, 0x61, 0x30,
	0x89, 0x6f, 0xab, 0xcb, 0xe3, 0x9b, 0x32, 0x81, 0x4a, 0x14, 0xba, 0xa8, 0x63, 0x4e, 0x6f, 0x5d,
	0x9a, 0xd9, 0xfa, 0xd2, 0xba, 0xf8, 0x23, 0xa8, 0xa6, 0x8b, 0x3a, 0xd1, 0x95, 0x90, 0x9e, 0x92,
	0x4a, 0xaa, 0x96, 0x53, 0xfe, 0x4c, 0x8a, 0x1d, 0x0e, 0x5b, 0x97, 0x50, 0x83, 0x5a, 0xe3, 0xe0,
	0x7b, 0x58, 0xfe, 0x25, 0x40, 0x2a, 0xf3, 0xc8, 0x2f, 0xcf, 0x3c, 0xca, 0xa3, 0xe8, 0x53, 0xf9,
	0x2b, 0x29, 0x49, 0xfc, 0xa8, 0x63, 0x72, 0x73, 0xfe, 0x1e, 0x58, 0x8a, 0x8f, 0x4e, 0x7e, 0x6e,
	0x53, 0x6a, 0xe1, 0xd1, 0x29, 0x70, 0xbb, 0x8c, 0xdd, 0xf9, 0x5f, 0x4a, 0x71, 0xad, 0x22, 0x76,
	0x31, 0x9d, 0x1c, 0x4a, 0x33, 0xc9, 0x61, 0x56, 0x22, 0x8c, 0xbd, 0x4b, 0x4b, 0x84, 0x25, 0xce,
	0x1e, 0x35, 0xa9, 0x6d, 0x9d, 0x51, 0xef, 0x5c, 0x33, 0xdc, 0x89, 0x13, 0x70, 0x99, 0xf2, 0x82,
	0xbe, 0x91, 0x0c, 0xb5, 0xd9, 0x88, 0xf2, 0xbf, 0x79, 0x00, 0xc1, 0x5d, 0xcb, 0x38, 0x5d, 0xce,
	0xd9, 0x8f, 0xa1, 0xa4, 0x1b, 0xa7, 0x1a, 0x6f, 0xd8, 0xe5, 0xb8, 0x6c, 0x9a, 0x73, 0x1d, 0x5e,
	0xcb, 0x38, 0xdd, 0x6a, 0x19, 0xa7, 0x61, 0x52, 0xac, 0x87, 0x2f, 0x33, 0x8a, 0xce, 0x7f, 0xc0,
	0xb6, 0xfa, 0x80, 0xce, 0x74, 0xdb, 0x32, 0x75, 0x5e, 0x35, 0xa6, 0x63, 0xed, 0xe6, 0x85, 0x0c,
	0xbc, 0x8d, 0x27, 0x84, 0xba, 0x6a, 0x9c, 0x65, 0x01, 0x8c, 0xa1, 0x99, 0x5e, 0xe2, 0xad, 0x99,
	0xd3, 0x1a, 0x37, 0xcc, 0x32, 0xfd, 0xc4, 0x4f, 0x61, 0x55, 0x6c, 0x10, 0xd7, 0x01, 0x3a, 0x8e,
	0x69, 0x9d, 0x59, 0xe6, 0x44, 0xb7, 0xd1, 0x15, 0xf6, 0xdd, 0x9e, 0x8c, 0x26, 0x36, 0x77, 0xc3,
	0x48, 0x52, 0xfe, 0x54, 0x82, 0xc6, 0x14, 0x2f, 0x78, 0x03, 0x6e, 0x1d, 0x4d, 0x35, 0x57, 0xda,
	0xae, 0xe7, 0x4d, 0x78, 0x01, 0x82, 0xae, 0xe0, 0x75, 0xc0, 0xbb, 0x34, 0xd5, 0xa9, 0xe1, 0xb3,
	0x90, 0x84, 0xd7, 0x00, 0xb5, 0x4f, 0xa8, 0x71, 0xea, 0x4f, 0x46, 0x07, 0x96, 0x3f, 0xd2, 0x03,
	0xe3, 0x04, 0xe5, 0xf0, 0x4d, 0xb8, 0xce, 0x3b, 0x2d, 0xbb, 0xb4, 0x4f, 0x3d, 0x4b, 0xb7, 0xad,
	0xaf, 0x69, 0x38, 0x21, 0x8f, 0xaf, 0x41, 0x63, 0x97, 0x46, 0x1d, 0x8d, 0x10, 0x58, 0x50, 0x8e,
	0xe1, 0x76, 0x2c, 0x27, 0xc6, 0x64, 0x5b, 0x68, 0xb8, 0x7d, 0xa2, 0x3b, 0x97, 0x31, 0x50, 0x05,
	0xca, 0x96, 0xaf, 0xe9, 0x7c, 0x2e, 0x8f, 0x8f, 0xb1, 0x27, 0x2c, 0x59, 0x7e, 0x48, 0x52, 0x79,
	0x1b, 0xbb, 0xa9, 0x57, 0xb6, 0xfb, 0xd5, 0x72, 0x9a, 0x1f, 0x43, 0x5d, 0xa8, 0xfb, 0x90, 0x7a,
	0x23, 0x2b, 0xf0, 0xb9, 0x81, 0xd5, 0xc8, 0x14, 0x54, 0x19, 0xc4, 0x6e, 0xe8, 0xc8, 0xf1, 0xe3,
	0x62, 0x6f, 0x29, 0xf9, 0xc5, 0x29, 0x90, 0xf2, 0xc7, 0x52, 0xca, 0xab, 0xd2, 0xd3, 0xef, 0x4a,
	0xef, 0x3b, 0x39, 0xb5, 0x1f, 0x83, 0x2c, 0x58, 0x21, 0x54, 0x37, 0x4e, 0xa8, 0xa9, 0x3a, 0x66,
	0xef, 0xdd, 0x20, 0x0a, 0x74, 0x0b, 0xf9, 0x52, 0xde, 0xc2, 0x5a, 0x54, 0x73, 0xdb, 0xae, 0x4f,
	0xe3, 0xb8, 0xb9, 0xd4, 0x29, 0x2e, 0x11, 0xd0, 0x14, 0xdd, 0xc8, 0x62, 0xbe, 0xb3, 0xe0, 0xff,
	0x48, 0x82, 0x8f, 0xe3, 0xdd, 0x0a, 0xe7, 0x74, 0xe4, 0xe8, 0xc6, 0xa9, 0xe3, 0x7e, 0xc5, 0xdb,
	0xe9, 0x91, 0xdb, 0xf4, 0x97, 0x2f, 0xf5, 0x13, 0xa8, 0x24, 0x42, 0x67, 0xf6, 0xb3, 0xd4, 0xc3,
	0x40, 0x2c, 0x75, 0x5f, 0xf9, 0x65, 0xec, 0xa8, 0x45, 0xc6, 0x3d, 0xc5, 0xba, 0x34, 0xad, 0xe3,
	0x24, 0x6c, 0xe7, 0x2e, 0x11, 0xb6, 0xff, 0x4e, 0x82, 0xf5, 0xa9, 0x64, 0xe6, 0x92, 0xeb, 0xcc,
	0x24, 0x27, 0xb9, 0x39, 0xdd, 0xef, 0xcf, 0x00, 0xd9, 0xba, 0x1f, 0x68, 0xe9, 0xc0, 0xc6, 0xcc,
	0x2e, 0xcf, 0xaf, 0x0e, 0xea, 0x6c, 0xac, 0x9f, 0x04, 0xb8, 0xd9, 0xa6, 0x66, 0x61, 0x4e, 0x53,
	0x53, 0x79, 0x0f, 0x55, 0xc1, 0x72, 0xe8, 0xb5, 0x96, 0x30, 0x1a, 0x87, 0xcd, 0xdc, 0x87, 0x87,
	0xcd, 0x7c, 0x36, 0x6c, 0xd6, 0xe2, 0xe3, 0x78, 0x68, 0x39, 0xc3, 0xf4, 0xa7, 0xeb, 0x0c, 0xd3,
	0xc6, 0x28, 0xb4, 0xdf, 0x0f, 0xf4, 0x60, 0xa9, 0x20, 0x97, 0x75, 0x65, 0x94, 0xff, 0x29, 0xc0,
	0x9d, 0x79, 0x84, 0xc9, 0xfc, 0xfc, 0x7c, 0x66, 0x81, 0x1f, 0x01, 0xf0, 0x8d, 0x69, 0x86, 0x6b,
	0x52, 0xd1, 0x5d, 0x5c, 0x20, 0x85, 0x32, 0x47, 0x6e, 0xbb, 0x26, 0xcb, 0x2d, 0x6b, 0xe1, 0xcc,
	0x44, 0x1e, 0x3c, 0x01, 0xe5, 0xc0, 0x28, 0x71, 0xd8, 0x00, 0x18, 0xf9, 0x43, 0xa2, 0x07, 0xb4,
	0x27, 0x9a, 0xb0, 0x12, 0x49, 0x41, 0x58, 0xb1, 0x33, 0xf2, 0x87, 0x22, 0xf9, 0x1e, 0x4f, 0x02,
	0x86, 0x55, 0xe4, 0x58, 0x33, 0x70, 0x81, 0xcb, 0x66, 0xc6, 0xc7, 0x8e, 0x17, 0x0a, 0x21, 0x6e,
	0x06, 0x8e, 0x15, 0xc8, 0x34, 0x9e, 0x44, 0x75, 0x90, 0x6d, 0x46, 0x3d, 0x02, 0xa4, 0x9f, 0xe9,
	0x96, 0xad, 0x1f, 0xdb, 0xb1, 0x03, 0x67, 0x95, 0x41, 0x81, 0xcc, 0xc0, 0xf1, 0x26, 0x34, 0x26,
	0xec, 0x88, 0x27, 0x67, 0x9b, 0x37, 0x9c, 0x0a, 0x64, 0x1a, 0x8c, 0x77, 0xe0, 0xce, 0xb1, 0xed,
	0x32, 0x50, 0xa4, 0x8f, 0x9e, 0x73, 0x24, 0x70, 0xfc, 0xa1, 0x2f, 0x03, 0x6f, 0x17, 0x2d, 0xc4,
	0x61, 0x46, 0xa6, 0x9b, 0x26, 0x8b, 0xa3, 0xbc, 0xbb, 0x54, 0x26, 0xd1, 0x27, 0x0b, 0x39, 0x46,
	0xd4, 0x98, 0xec, 0x5b, 0x8e, 0x11, 0xde, 0x4d, 0x94, 0xc9, 0x14, 0x14, 0x63, 0x71, 0x45, 0x59,
	0xe3, 0xa3, 0xe1, 0x3d, 0x24, 0x0b, 0x57, 0xa1, 0x9c, 0xd4, 0xf7, 0x63, 0xcb, 0xa3, 0x26, 0xbf,
	0x69, 0x90, 0xc8, 0x14, 0x54, 0xe8, 0x6c, 0x47, 0x37, 0x4e, 0x6d, 0x77, 0xc8, 0xef, 0x18, 0x0a,
	0x24, 0x05, 0x51, 0x7e, 0x0e, 0x37, 0x84, 0xc5, 0xbd, 0xa6, 0xc1, 0xbe, 0xee, 0xa7, 0x3a, 0x6a,
	0xdf, 0xd5, 0xb5, 0x7e, 0x93, 0x74, 0x91, 0xa6, 0x69, 0xc7, 0x06, 0xdd, 0x86, 0x06, 0x77, 0x1b,
	0xa9, 0x60, 0x25, 0x2d, 0xcf, 0x37, 0x6b, 0x76, 0x86, 0xd1, 0x25, 0x7c, 0xfc, 0x9b, 0x14, 0xa7,
	0x1b, 0xaf, 0x69, 0xc0, 0xe3, 0x98, 0xdf, 0x7b, 0xc7, 0xac, 0xc6, 0x1f, 0xeb, 0xc6, 0xd2, 0x43,
	0x75, 0x07, 0xca, 0x4e, 0x84, 0x2b, 0x5c, 0x5f, 0x02, 0xc0, 0x5d, 0x28, 0x8c, 0xd8, 0x61, 0xcb,
	0x2f, 0x68, 0xf1, 0xcd, 0x5b, 0x75, 0xeb, 0xc0, 0x35, 0xe9, 0x4b, 0x38, 0x54, 0x49, 0xbf, 0xd3,
	0x1f, 0xa8, 0xdd, 0x01, 0xe1, 0x74, 0x94, 0x67, 0x50, 0x60, 0x23, 0x2c, 0x89, 0x4b, 0xc6, 0xd0,
	0x15, 0x8c, 0xa1, 0xde, 0xed, 0x75, 0xb5, 0x14, 0x4c, 0xc2, 0xab, 0x90, 0x6f, 0xed, 0xef, 0xa3,
	0x9c, 0xf2, 0x0b, 0x78, 0xb0, 0x60, 0xa9, 0xcb, 0x7a, 0x8f, 0x75, 0x58, 0xe1, 0xd5, 0x6c, 0x18,
	0xb9, 0xca, 0x44, 0x7c, 0x29, 0x4e, 0x5c, 0xe3, 0xbc, 0xa6, 0x81, 0xb8, 0x6a, 0x5f, 0x42, 0x2a,
	0xae, 0x92, 0x73, 0xe9, 0x2a, 0x79, 0xd6, 0xeb, 0xe7, 0xe7, 0x79, 0xfd, 0xff, 0x96, 0xe2, 0x04,
	0x24, 0x5e, 0xf0, 0x37, 0xc4, 0x03, 0x26, 0x21, 0xb7, 0x70, 0x89, 0x4e, 0xf0, 0xec, 0x7e, 0x8b,
	0xf3, 0xf6, 0xfb, 0x0f, 0x37, 0xa1, 0xb2, 0xa3, 0xb3, 0x9c, 0x86, 0xef, 0x19, 0x6f, 0x8b, 0xe3,
	0x2e, 0xf1, 0x28, 0xb6, 0x91, 0x5d, 0x22, 0x85, 0x98, 0xfd, 0x2d, 0x61, 0x55, 0x38, 0x0d, 0x91,
	0x0c, 0xdc, 0x99, 0x6b, 0x89, 0xa2, 0xcf, 0x41, 0x22, 0x64, 0xfc, 0x13, 0x28, 0xc7, 0xce, 0x46,
	0xa4, 0x89, 0x1b, 0x8b, 0x66, 0x52, 0x93, 0x24, 0x13, 0xd8, 0xec, 0x38, 0x05, 0x16, 0x12, 0xd9,
	0x58, 0xdc, 0xe4, 0x26, 0xc9, 0x04, 0xfc, 0x39, 0x94, 0xa2, 0x14, 0x82, 0x0b, 0xa6, 0x32, 0xe7,
	0x02, 0x39, 0x9d, 0xae, 0x90, 0x18, 0x1d, 0x3f, 0x86, 0x82, 0x4f, 0x9d, 0xb0, 0x2f, 0x57, 0x99,
	0x56, 0x70, 0xba, 0x4b, 0xc0, 0xd1, 0x70, 0x1b, 0xaa, 0xec, 0xa9, 0x79, 0x61, 0xd3, 0x40, 0xb4,
	0x39, 0x9a, 0x17, 0x4f, 0x0b, 0xf1, 0x48, 0xc5, 0x4f, 0x75, 0x1a, 0x7e, 0x07, 0x80, 0x13, 0x09,
	0x53, 0x8c, 0xd2, 0xa2, 0xdd, 0x46, 0xad, 0x00, 0x52, 0xf6, 0xe3, 0xae, 0xc0, 0x8b, 0x24, 0xd7,
	0x28, 0x2f, 0xd0, 0x90, 0xb0, 0xb4, 0xa4, 0xf7, 0xf5, 0x08, 0xf2, 0xba, 0x71, 0xca, 0x23, 0x4d,
	0x65, 0xfa, 0xaa, 0x30, 0x29, 0x36, 0x09, 0x43, 0x62, 0x62, 0x79, 0x67, 0xbb, 0x5f, 0xf1, 0x38,
	0x73, 0x91, 0x58, 0x58, 0x35, 0x44, 0x38, 0x1a, 0xde, 0x81, 0xca, 0x24, 0xa9, 0x61, 0xc4, 0xe5,
	0xc6, 0x7c, 0xa9, 0xa4, 0x6a, 0x1d, 0x92, 0x9e, 0xc4, 0xb6, 0xe5, 0x87, 0x69, 0x24, 0x0f, 0x4f,
	0x17, 0x6d, 0x4b, 0xa4, 0x9a, 0x24, 0x42, 0xc6, 0x4f, 0xa2, 0x5c, 0xad, 0xce, 0x67, 0xdd, 0x9a,
	0x3b, 0x2b, 0x93, 0xac, 0x75, 0xa0, 0x6e, 0xb0, 0xd4, 0x5f, 0x8b, 0x8d, 0xa6, 0xc1, 0xa7, 0x2a,
	0xf3, 0xed, 0x35, 0x5d, 0x7d, 0x90, 0x9a, 0x91, 0x29, 0x46, 0x62, 0x52, 0x51, 0x30, 0xe3, 0x77,
	0xea, 0x0b, 0x49, 0x45, 0xb1, 0x5d, 0x90, 0x8a, 0xeb, 0x8f, 0x1e, 0xbf, 0x28, 0x0c, 0x93, 0xe3,
	0x48, 0x10, 0x57, 0x39, 0xb1, 0x8f, 0x16, 0x1a, 0x73, 0x24, 0x90, 0xc6, 0x78, 0x2a, 0x19, 0x7f,
	0x0c, 0x85, 0xb1, 0xe5, 0x0c, 0x65, 0xbc, 0x40, 0x87, 0x2c, 0x27, 0x25, 0x1c, 0x8d, 0xa3, 0xbb,
	0xce, 0x50, 0xbe, 0xb6, 0x08, 0xdd, 0xe5, 0xe8, 0xae, 0x33, 0xc4, 0x7f, 0x08, 0xf7, 0xbc, 0xc5,
	0x65, 0x8e, 0xbc, 0xc6, 0x29, 0x3d, 0x9f, 0x4b, 0x69, 0x49, 0x89, 0x44, 0x96, 0x11, 0xc7, 0xbf,
	0x0f, 0x57, 0xe3, 0x3b, 0x93, 0xe8, 0x6a, 0x43, 0xbe, 0xce, 0x57, 0x7c, 0xfc, 0x61, 0xf7, 0x21,
	0xb3, 0x74, 0xb0, 0x9f, 0xba, 0xd9, 0x9f, 0xbe, 0x37, 0x91, 0xd7, 0xf9, 0x22, 0x3f, 0xfc, 0xb5,
	0x2e, 0x5d, 0xc8, 0xc5, 0x74, 0xd9, 0x21, 0xb2, 0x93, 0xf6, 0xba, 0x7c, 0x63, 0xc1, 0x21, 0x4a,
	0xb7, 0xe1, 0xd3, 0x93, 0xf0, 0x97, 0x70, 0xcd, 0x9e, 0x6d, 0xd1, 0xcb, 0x32, 0xa7, 0xb5, 0x79,
	0xd9, 0x96, 0x3e, 0x99, 0x47, 0x04, 0xbf, 0x49, 0xae, 0x72, 0x79, 0x2d, 0x21, 0xdf, 0x5c, 0x64,
	0xea, 0x99, 0xaa, 0x23, 0x3b, 0x11, 0xff, 0x0a, 0xae, 0x1b, 0xf3, 0xaa, 0x12, 0xf9, 0x16, 0xa7,
	0xf8, 0xe8, 0x12, 0x14, 0x23, 0x4e, 0xe7, 0x13, 0xc2, 0x03, 0xb8, 0xea, 0x4d, 0xb7, 0x1c, 0xe4,
	0xdb, 0x9c, 0xfa, 0xc7, 0x17, 0xd8, 0xe3, 0x14, 0x36, 0x99, 0x25, 0x10, 0x06, 0x0b, 0x7a, 0x2a,
	0xdf, 0x59, 0x18, 0x2c, 0xe8, 0x29, 0xe1, 0x68, 0xf8, 0xa7, 0x80, 0x86, 0x53, 0xe9, 0xaa, 0x7c,
	0x97, 0x4f, 0x7d, 0x78, 0x51, 0x76, 0x97, 0xcd, 0x6d, 0x67, 0xa6, 0x63, 0x0b, 0xe4, 0xe1, 0x05,
	0x19, 0xb0, 0xbc, 0xb1, 0xc0, 0xf8, 0x2f, 0x4a, 0x9b, 0xc9, 0x85, 0xe4, 0xb0, 0x06, 0xeb, 0x61,
	0x5f, 0x2c, 0xf6, 0x6d, 0x9a, 0xc1, 0xbb, 0x6a, 0xf2, 0x3d, 0xbe, 0xd0, 0xa7, 0x17, 0x44, 0x90,
	0xd9, 0x36, 0x1c, 0x59, 0xd3, 0xe7, 0x35, 0xe7, 0x7e, 0x09, 0x6b, 0xc3, 0x39, 0x49, 0xa6, 0xdc,
	0x5c, 0x40, 0x7e, 0x6e, 0x56, 0x3a, 0x97, 0x0c, 0x9e, 0xc0, 0x9d, 0xe1, 0x82, 0x1c, 0x56, 0xbe,
	0xcf, 0x97, 0x79, 0x7a, 0xf9, 0x65, 0x22, 0x91, 0x2d, 0x24, 0xcb, 0x32, 0x99, 0x61, 0x94, 0x6b,
	0xca, 0xca, 0x82, 0xd8, 0x9e, 0x64, 0xa4, 0xc9, 0x04, 0x66, 0xb7, 0xc3, 0xe9, 0x4c, 0x55, 0x7e,
	0xb0, 0xc0, 0x6e, 0x67, 0xf2, 0x5a, 0x32, 0x4b, 0x40, 0xf9, 0xeb, 0xa2, 0xf8, 0x67, 0xb4, 0x02,
	0xab, 0xed, 0x5e, 0xb7, 0xab, 0xb6, 0x07, 0x28, 0x87, 0x6b, 0x50, 0x16, 0x1f, 0xea, 0x2e, 0xca,
	0xb3, 0xcf, 0xfe, 0xd1, 0x4e, 0xbf, 0x4d, 0x3a, 0x3b, 0x2a, 0x2a, 0xf0, 0xdf, 0x47, 0x49, 0x6f,
	0xf7, 0xa8, 0xad, 0x12, 0x54, 0xc4, 0x25, 0x28, 0xf4, 0xd5, 0xee, 0x2e, 0x5a, 0xc1, 0x08, 0xaa,
	0xec, 0x4d, 0x23, 0x6a, 0x5b, 0xed, 0x1c, 0x0e, 0xd0, 0x2a, 0x2b, 0x30, 0x38, 0x44, 0x25, 0xa4,
	0x47, 0x50, 0x89, 0x2d, 0x72, 0xa0, 0xf6, 0xfb, 0xad, 0xd7, 0x2a, 0x2a, 0xf3, 0xca, 0xa2, 0xbd,
	0x87, 0x80, 0x51, 0x78, 0xb5, 0xdf, 0xfb, 0x19, 0xaa, 0xe0, 0x06, 0x54, 0x8e, 0xba, 0xc9, 0x52,
	0x55, 0x7e, 0x35, 0x7c, 0xd4, 0x6e, 0xab, 0xfd, 0x3e, 0xaa, 0xe1, 0x32, 0x14, 0x43, 0x42, 0x75,
	0x56, 0xa9, 0xb4, 0xf7, 0x7b, 0x7d, 0x55, 0x8b, 0x19, 0x69, 0x24, 0xb0, 0x76, 0xaf, 0xdb, 0x3f,
	0x3a, 0x50, 0x09, 0x42, 0x78, 0x0d, 0x50, 0x84, 0xa1, 0x45, 0x84, 0xae, 0xb2, 0x05, 0x0f, 0x3b,
	0xdd, 0xd7, 0x08, 0xf3, 0xb7, 0x5e, 0xf7, 0x35, 0xba, 0x86, 0x1f, 0xc2, 0x7d, 0xa2, 0xee, 0xaa,
	0xfb, 0x9d, 0xb7, 0x2a, 0xd1, 0x8e, 0xba, 0xad, 0xf6, 0x5e, 0xb7, 0xf7, 0xb3, 0x7d, 0x75, 0xf7,
	0xb5, 0xba, 0xab, 0x09, 0x9e, 0xfb, 0x68, 0x0d, 0xcb, 0xb0, 0x76, 0xd8, 0x22, 0x83, 0xce, 0xa0,
	0xd3, 0xeb, 0xf2, 0x91, 0x41, 0x6b, 0xb7, 0x35, 0x68, 0xa1, 0xeb, 0xf8, 0x3e, 0xdc, 0x9d, 0x37,
	0xa2, 0x11, 0xb5, 0x7f, 0xd8, 0xeb, 0xf6, 0x55, 0xb4, 0xce, 0x7f, 0x86, 0xe8, 0xf5, 0xf6, 0x8e,
	0x0e, 0xd1, 0x0d, 0x7c, 0x0d, 0x1a, 0xe1, 0x7b, 0x82, 0x20, 0xf3, 0x2d, 0x08, 0xe6, 0xb5, 0xfe,
	0xa0, 0x35, 0xe8, 0xa3, 0x9b, 0xf8, 0x36, 0xdc, 0xc8, 0xc2, 0x92, 0x09, 0xb7, 0x18, 0x3b, 0x44,
	0x6d, 0xb5, 0xdf, 0xa8, 0xbb, 0x1a, 0x93, 0x73, 0xef, 0x95, 0x36, 0xe8, 0x1d, 0x76, 0xda, 0xe8,
	0x76, 0xa8, 0x16, 0x75, 0x0f, 0xdd, 0xc1, 0x37, 0xe0, 0xda, 0x6b, 0x75, 0xa0, 0xed, 0xb7, 0xfa,
	0x83, 0x68, 0x27, 0x5a, 0x67, 0x17, 0xdd, 0xc5, 0x4d, 0xb8, 0x33, 0x67, 0x20, 0x21, 0xbf, 0x81,
	0x6f, 0xc1, 0x7a, 0xab, 0x3d, 0xe8, 0xbc, 0x4d, 0x64, 0xaa, 0xb5, 0xdf, 0xb4, 0xba, 0xaf, 0x55,
	0x74, 0x8f, 0xf1, 0xc5, 0x66, 0xf3, 0xf5, 0xfa, 0x6c, 0xe5, 0x6e, 0xeb, 0x40, 0xed, 0x1f, 0xb6,
	0xda, 0x2a, 0x6a, 0xe2, 0x8f, 0xa0, 0x79, 0xc1, 0x60, 0x42, 0xfe, 0x3e, 0x33, 0x0f, 0x86, 0xd5,
	0x6f, 0xbf, 0x51, 0x0f, 0x5a, 0x48, 0x89, 0x38, 0x0d, 0xbf, 0x13, 0xc4, 0x07, 0x8f, 0xb6, 0xf8,
	0x1d, 0x69, 0xfa, 0x47, 0x4f, 0xfe, 0x8f, 0x73, 0xaf, 0xab, 0xa2, 0x2b, 0xcc, 0x8e, 0xf6, 0xbf,
	0x7c, 0x1e, 0xfe, 0xe0, 0xfc, 0xe5, 0x7e, 0x67, 0x07, 0xe5, 0x1e, 0xfd, 0x63, 0x1e, 0x2a, 0xa9,
	0x12, 0x8c, 0x59, 0xe6, 0x91, 0xc3, 0x32, 0x05, 0x71, 0x3b, 0x70, 0x05, 0x5f, 0x85, 0x5a, 0x14,
	0x65, 0x53, 0xd7, 0x0e, 0x87, 0xac, 0x5a, 0xf2, 0x03, 0xea, 0x18, 0xe2, 0x6e, 0x21, 0xc7, 0x78,
	0x6a, 0x4d, 0x82, 0x13, 0xea, 0x04, 0x96, 0x91, 0xdc, 0x6d, 0xa0, 0x3c, 0x5e, 0x07, 0xdc, 0x0a,
	0xef, 0xa2, 0xbf, 0x4e, 0xc1, 0x0b, 0x6c, 0xad, 0xc8, 0x9b, 0xed, 0x4c, 0xfc, 0x73, 0x54, 0x64,
	0xaa, 0x16, 0xb7, 0xc4, 0x5d, 0x37, 0x20, 0x54, 0x37, 0xcf, 0xd1, 0x0a, 0xb3, 0xb7, 0x28, 0x4d,
	0xdb, 0x09, 0x3b, 0x3b, 0x3f, 0x9d, 0xb8, 0x81, 0xae, 0xbe, 0x37, 0x28, 0x35, 0x69, 0x98, 0x95,
	0xa2, 0x55, 0xfc, 0x29, 0x3c, 0x5c, 0x88, 0xf6, 0xde, 0xa0, 0xe1, 0x75, 0x4a, 0x89, 0x6d, 0x29,
	0xba, 0x36, 0x09, 0x67, 0x97, 0x99, 0x8e, 0x58, 0x52, 0x3d, 0x1e, 0xbb, 0x5e, 0x40, 0x4d, 0x51,
	0x0b, 0x86, 0x83, 0xc0, 0xf0, 0xb9, 0xaf, 0xea, 0xba, 0xc1, 0x2b, 0x77, 0xe2, 0x98, 0xa8, 0xc2,
	0xcc, 0xa9, 0x9f, 0xfa, 0x49, 0x2c, 0x1e, 0xa9, 0xf2, 0x3b, 0x99, 0xa8, 0x15, 0x16, 0x41, 0x6b,
	0x6c, 0x67, 0x03, 0xd7, 0x3d, 0xd0, 0x9d, 0x73, 0x12, 0x56, 0xc7, 0x3e, 0xaa, 0x33, 0x22, 0x9c,
	0xee, 0x80, 0x7a, 0x23, 0xcb, 0xd1, 0x83, 0x68, 0x33, 0x0d, 0x26, 0x9a, 0x78, 0x33, 0x4c, 0x34,
	0xfc, 0x7c, 0x76, 0x1c, 0x7e, 0x65, 0x15, 0xb2, 0xa2, 0x8f, 0x28, 0xba, 0xfa, 0x68, 0x0f, 0x20,
	0xf9, 0xfb, 0x81, 0x1d, 0x8a, 0xe4, 0x4b, 0xfc, 0xd7, 0x7e, 0x0d, 0x1a, 0x09, 0xec, 0xe7, 0x86,
	0xfe, 0xf6, 0x69, 0xa8, 0xc0, 0x04, 0xd8, 0x62, 0x3a, 0xf3, 0x51, 0xee, 0xd1, 0x37, 0x12, 0x34,
	0x0e, 0xa7, 0x7e, 0x39, 0x5c, 0x81, 0xdc, 0xd9, 0x13, 0x74, 0x85, 0x3f, 0xd9, 0x4c, 0xf6, 0xdc,
	0x46, 0x39, 0xfe, 0x7c, 0x86, 0xf2, 0xfc, 0xf9, 0x1c, 0x15, 0xf8, 0xf3, 0x87, 0xa8, 0xc8, 0x9f,
	0x2f, 0xd0, 0x0a, 0x7f, 0xfe, 0x36, 0x5a, 0xe5, 0xcf, 0x1f, 0xa1, 0x12, 0x7f, 0x7e, 0x1e, 0xba,
	0xb2, 0xb3, 0xa7, 0x4f, 0x10, 0x84, 0x2f, 0x4f, 0x51, 0x25, 0x7c, 0xd9, 0x46, 0xd5, 0xf0, 0xe5,
	0x19, 0xaa, 0xed, 0xbc, 0xfc, 0xa7, 0x6f, 0x37, 0xa4, 0x7f, 0xf9, 0x76, 0x43, 0xfa, 0xf7, 0x6f,
	0x37, 0xa4, 0xbf, 0xf8, 0x8f, 0x8d, 0x2b, 0xa0, 0xb8, 0xde, 0x70, 0x4b, 0x1f, 0xb3, 0x54, 0x22,
	0x72, 0xe0, 0x86, 0x3b, 0x1a, 0xb9, 0xce, 0x96, 0x3e, 0xb6, 0x42, 0x5f, 0xfe, 0x26, 0xff, 0x65,
	0x6e, 0x7c, 0xfc, 0xff, 0x01, 0x00, 0x00, 0xff, 0xff, 0xb1, 0x43, 0x35, 0x48, 0x9c, 0x30, 0x00,
	0x00,
}

func (m *Schema) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Schema) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.Name)))
		i += copy(dAtA[i:], *m.Name)
	}
	if m.SchemaData == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(m.SchemaData)))
		i += copy(dAtA[i:], m.SchemaData)
	}
	if m.Type == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.Type))
	}
	if len(m.Properties) > 0 {
		for _, msg := range m.Properties {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintPulsar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MessageIdData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageIdData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LedgerId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.LedgerId))
	}
	if m.EntryId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.EntryId))
	}
	if m.Partition != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.Partition))
	}
	if m.BatchIndex != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.BatchIndex))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KeyValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.Key)))
		i += copy(dAtA[i:], *m.Key)
	}
	if m.Value == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.Value)))
		i += copy(dAtA[i:], *m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KeyLongValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyLongValue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.Key)))
		i += copy(dAtA[i:], *m.Key)
	}
	if m.Value == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.Value))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EncryptionKeys) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptionKeys) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.Key)))
		i += copy(dAtA[i:], *m.Key)
	}
	if m.Value == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if len(m.Metadata) > 0 {
		for _, msg := range m.Metadata {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintPulsar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MessageMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProducerName == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.ProducerName)))
		i += copy(dAtA[i:], *m.ProducerName)
	}
	if m.SequenceId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.SequenceId))
	}
	if m.PublishTime == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.PublishTime))
	}
	if len(m.Properties) > 0 {
		for _, msg := range m.Properties {
			dAtA[i] = 0x22
			i++
			i = encodeVarintPulsar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ReplicatedFrom != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.ReplicatedFrom)))
		i += copy(dAtA[i:], *m.ReplicatedFrom)
	}
	if m.PartitionKey != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.PartitionKey)))
		i += copy(dAtA[i:], *m.PartitionKey)
	}
	if len(m.ReplicateTo) > 0 {
		for _, s := range m.ReplicateTo {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Compression != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.Compression))
	}
	if m.UncompressedSize != nil {
		dAtA[i] = 0x48
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.UncompressedSize))
	}
	if m.NumMessagesInBatch != nil {
		dAtA[i] = 0x58
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.NumMessagesInBatch))
	}
	if m.EventTime != nil {
		dAtA[i] = 0x60
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.EventTime))
	}
	if len(m.EncryptionKeys) > 0 {
		for _, msg := range m.EncryptionKeys {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintPulsar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.EncryptionAlgo != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.EncryptionAlgo)))
		i += copy(dAtA[i:], *m.EncryptionAlgo)
	}
	if m.EncryptionParam != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(m.EncryptionParam)))
		i += copy(dAtA[i:], m.EncryptionParam)
	}
	if m.SchemaVersion != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(m.SchemaVersion)))
		i += copy(dAtA[i:], m.SchemaVersion)
	}
	if m.PartitionKeyB64Encoded != nil {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		if *m.PartitionKeyB64Encoded {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SingleMessageMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SingleMessageMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Properties) > 0 {
		for _, msg := range m.Properties {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPulsar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PartitionKey != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.PartitionKey)))
		i += copy(dAtA[i:], *m.PartitionKey)
	}
	if m.PayloadSize == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.PayloadSize))
	}
	if m.CompactedOut != nil {
		dAtA[i] = 0x20
		i++
		if *m.CompactedOut {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EventTime != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.EventTime))
	}
	if m.PartitionKeyB64Encoded != nil {
		dAtA[i] = 0x30
		i++
		if *m.PartitionKeyB64Encoded {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandConnect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandConnect) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ClientVersion == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.ClientVersion)))
		i += copy(dAtA[i:], *m.ClientVersion)
	}
	if m.AuthMethod != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.AuthMethod))
	}
	if m.AuthData != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(m.AuthData)))
		i += copy(dAtA[i:], m.AuthData)
	}
	if m.ProtocolVersion != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.ProtocolVersion))
	}
	if m.AuthMethodName != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.AuthMethodName)))
		i += copy(dAtA[i:], *m.AuthMethodName)
	}
	if m.ProxyToBrokerUrl != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.ProxyToBrokerUrl)))
		i += copy(dAtA[i:], *m.ProxyToBrokerUrl)
	}
	if m.OriginalPrincipal != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.OriginalPrincipal)))
		i += copy(dAtA[i:], *m.OriginalPrincipal)
	}
	if m.OriginalAuthData != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.OriginalAuthData)))
		i += copy(dAtA[i:], *m.OriginalAuthData)
	}
	if m.OriginalAuthMethod != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.OriginalAuthMethod)))
		i += copy(dAtA[i:], *m.OriginalAuthMethod)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandConnected) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandConnected) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ServerVersion == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.ServerVersion)))
		i += copy(dAtA[i:], *m.ServerVersion)
	}
	if m.ProtocolVersion != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.ProtocolVersion))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandSubscribe) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandSubscribe) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Topic == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.Topic)))
		i += copy(dAtA[i:], *m.Topic)
	}
	if m.Subscription == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.Subscription)))
		i += copy(dAtA[i:], *m.Subscription)
	}
	if m.SubType == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.SubType))
	}
	if m.ConsumerId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.ConsumerId))
	}
	if m.RequestId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.RequestId))
	}
	if m.ConsumerName != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.ConsumerName)))
		i += copy(dAtA[i:], *m.ConsumerName)
	}
	if m.PriorityLevel != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.PriorityLevel))
	}
	if m.Durable != nil {
		dAtA[i] = 0x40
		i++
		if *m.Durable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.StartMessageId != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.StartMessageId.Size()))
		n1, err := m.StartMessageId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Metadata) > 0 {
		for _, msg := range m.Metadata {
			dAtA[i] = 0x52
			i++
			i = encodeVarintPulsar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ReadCompacted != nil {
		dAtA[i] = 0x58
		i++
		if *m.ReadCompacted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Schema != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.Schema.Size()))
		n2, err := m.Schema.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.InitialPosition != nil {
		dAtA[i] = 0x68
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.InitialPosition))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandPartitionedTopicMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandPartitionedTopicMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Topic == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.Topic)))
		i += copy(dAtA[i:], *m.Topic)
	}
	if m.RequestId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.RequestId))
	}
	if m.OriginalPrincipal != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.OriginalPrincipal)))
		i += copy(dAtA[i:], *m.OriginalPrincipal)
	}
	if m.OriginalAuthData != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.OriginalAuthData)))
		i += copy(dAtA[i:], *m.OriginalAuthData)
	}
	if m.OriginalAuthMethod != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.OriginalAuthMethod)))
		i += copy(dAtA[i:], *m.OriginalAuthMethod)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandPartitionedTopicMetadataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandPartitionedTopicMetadataResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Partitions != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.Partitions))
	}
	if m.RequestId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.RequestId))
	}
	if m.Response != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.Response))
	}
	if m.Error != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.Error))
	}
	if m.Message != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.Message)))
		i += copy(dAtA[i:], *m.Message)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandLookupTopic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandLookupTopic) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Topic == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.Topic)))
		i += copy(dAtA[i:], *m.Topic)
	}
	if m.RequestId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.RequestId))
	}
	if m.Authoritative != nil {
		dAtA[i] = 0x18
		i++
		if *m.Authoritative {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.OriginalPrincipal != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.OriginalPrincipal)))
		i += copy(dAtA[i:], *m.OriginalPrincipal)
	}
	if m.OriginalAuthData != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.OriginalAuthData)))
		i += copy(dAtA[i:], *m.OriginalAuthData)
	}
	if m.OriginalAuthMethod != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.OriginalAuthMethod)))
		i += copy(dAtA[i:], *m.OriginalAuthMethod)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandLookupTopicResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandLookupTopicResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BrokerServiceUrl != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.BrokerServiceUrl)))
		i += copy(dAtA[i:], *m.BrokerServiceUrl)
	}
	if m.BrokerServiceUrlTls != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.BrokerServiceUrlTls)))
		i += copy(dAtA[i:], *m.BrokerServiceUrlTls)
	}
	if m.Response != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.Response))
	}
	if m.RequestId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.RequestId))
	}
	if m.Authoritative != nil {
		dAtA[i] = 0x28
		i++
		if *m.Authoritative {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Error != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.Error))
	}
	if m.Message != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.Message)))
		i += copy(dAtA[i:], *m.Message)
	}
	if m.ProxyThroughServiceUrl != nil {
		dAtA[i] = 0x40
		i++
		if *m.ProxyThroughServiceUrl {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandProducer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandProducer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Topic == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.Topic)))
		i += copy(dAtA[i:], *m.Topic)
	}
	if m.ProducerId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.ProducerId))
	}
	if m.RequestId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.RequestId))
	}
	if m.ProducerName != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.ProducerName)))
		i += copy(dAtA[i:], *m.ProducerName)
	}
	if m.Encrypted != nil {
		dAtA[i] = 0x28
		i++
		if *m.Encrypted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Metadata) > 0 {
		for _, msg := range m.Metadata {
			dAtA[i] = 0x32
			i++
			i = encodeVarintPulsar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Schema != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.Schema.Size()))
		n3, err := m.Schema.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandSend) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandSend) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProducerId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.ProducerId))
	}
	if m.SequenceId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.SequenceId))
	}
	if m.NumMessages != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.NumMessages))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandSendReceipt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandSendReceipt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProducerId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.ProducerId))
	}
	if m.SequenceId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.SequenceId))
	}
	if m.MessageId != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.MessageId.Size()))
		n4, err := m.MessageId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandSendError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandSendError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProducerId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.ProducerId))
	}
	if m.SequenceId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.SequenceId))
	}
	if m.Error == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.Error))
	}
	if m.Message == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.Message)))
		i += copy(dAtA[i:], *m.Message)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConsumerId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.ConsumerId))
	}
	if m.MessageId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.MessageId.Size()))
		n5, err := m.MessageId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.RedeliveryCount != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.RedeliveryCount))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConsumerId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.ConsumerId))
	}
	if m.AckType == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.AckType))
	}
	if len(m.MessageId) > 0 {
		for _, msg := range m.MessageId {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintPulsar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ValidationError != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.ValidationError))
	}
	if len(m.Properties) > 0 {
		for _, msg := range m.Properties {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintPulsar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandActiveConsumerChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandActiveConsumerChange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConsumerId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.ConsumerId))
	}
	if m.IsActive != nil {
		dAtA[i] = 0x10
		i++
		if *m.IsActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandFlow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandFlow) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConsumerId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.ConsumerId))
	}
	if m.MessagePermits == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.MessagePermits))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandUnsubscribe) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandUnsubscribe) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConsumerId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.ConsumerId))
	}
	if m.RequestId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.RequestId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandSeek) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandSeek) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConsumerId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.ConsumerId))
	}
	if m.RequestId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.RequestId))
	}
	if m.MessageId != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.MessageId.Size()))
		n6, err := m.MessageId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandReachedEndOfTopic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandReachedEndOfTopic) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConsumerId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.ConsumerId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandCloseProducer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandCloseProducer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProducerId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.ProducerId))
	}
	if m.RequestId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.RequestId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandCloseConsumer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandCloseConsumer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConsumerId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.ConsumerId))
	}
	if m.RequestId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.RequestId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandRedeliverUnacknowledgedMessages) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandRedeliverUnacknowledgedMessages) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConsumerId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.ConsumerId))
	}
	if len(m.MessageIds) > 0 {
		for _, msg := range m.MessageIds {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPulsar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandSuccess) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandSuccess) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RequestId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.RequestId))
	}
	if m.Schema != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.Schema.Size()))
		n7, err := m.Schema.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandProducerSuccess) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandProducerSuccess) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RequestId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.RequestId))
	}
	if m.ProducerName == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.ProducerName)))
		i += copy(dAtA[i:], *m.ProducerName)
	}
	if m.LastSequenceId != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.LastSequenceId))
	}
	if m.SchemaVersion != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(m.SchemaVersion)))
		i += copy(dAtA[i:], m.SchemaVersion)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RequestId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.RequestId))
	}
	if m.Error == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.Error))
	}
	if m.Message == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.Message)))
		i += copy(dAtA[i:], *m.Message)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandPing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandPing) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandPong) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandPong) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandConsumerStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandConsumerStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RequestId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.RequestId))
	}
	if m.ConsumerId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.ConsumerId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandConsumerStatsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandConsumerStatsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RequestId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.RequestId))
	}
	if m.ErrorCode != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.ErrorCode))
	}
	if m.ErrorMessage != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.ErrorMessage)))
		i += copy(dAtA[i:], *m.ErrorMessage)
	}
	if m.MsgRateOut != nil {
		dAtA[i] = 0x21
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.MsgRateOut))))
		i += 8
	}
	if m.MsgThroughputOut != nil {
		dAtA[i] = 0x29
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.MsgThroughputOut))))
		i += 8
	}
	if m.MsgRateRedeliver != nil {
		dAtA[i] = 0x31
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.MsgRateRedeliver))))
		i += 8
	}
	if m.ConsumerName != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.ConsumerName)))
		i += copy(dAtA[i:], *m.ConsumerName)
	}
	if m.AvailablePermits != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.AvailablePermits))
	}
	if m.UnackedMessages != nil {
		dAtA[i] = 0x48
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.UnackedMessages))
	}
	if m.BlockedConsumerOnUnackedMsgs != nil {
		dAtA[i] = 0x50
		i++
		if *m.BlockedConsumerOnUnackedMsgs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Address != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.Address)))
		i += copy(dAtA[i:], *m.Address)
	}
	if m.ConnectedSince != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.ConnectedSince)))
		i += copy(dAtA[i:], *m.ConnectedSince)
	}
	if m.Type != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.Type)))
		i += copy(dAtA[i:], *m.Type)
	}
	if m.MsgRateExpired != nil {
		dAtA[i] = 0x71
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.MsgRateExpired))))
		i += 8
	}
	if m.MsgBacklog != nil {
		dAtA[i] = 0x78
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.MsgBacklog))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandGetLastMessageId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandGetLastMessageId) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConsumerId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.ConsumerId))
	}
	if m.RequestId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.RequestId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandGetLastMessageIdResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandGetLastMessageIdResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LastMessageId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.LastMessageId.Size()))
		n8, err := m.LastMessageId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.RequestId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.RequestId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandGetTopicsOfNamespace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandGetTopicsOfNamespace) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RequestId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.RequestId))
	}
	if m.Namespace == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.Namespace)))
		i += copy(dAtA[i:], *m.Namespace)
	}
	if m.Mode != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.Mode))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandGetTopicsOfNamespaceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandGetTopicsOfNamespaceResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RequestId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.RequestId))
	}
	if len(m.Topics) > 0 {
		for _, s := range m.Topics {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandGetSchema) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandGetSchema) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RequestId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.RequestId))
	}
	if m.Topic == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.Topic)))
		i += copy(dAtA[i:], *m.Topic)
	}
	if m.SchemaVersion != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(m.SchemaVersion)))
		i += copy(dAtA[i:], m.SchemaVersion)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommandGetSchemaResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandGetSchemaResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RequestId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.RequestId))
	}
	if m.ErrorCode != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.ErrorCode))
	}
	if m.ErrorMessage != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(*m.ErrorMessage)))
		i += copy(dAtA[i:], *m.ErrorMessage)
	}
	if m.Schema != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.Schema.Size()))
		n9, err := m.Schema.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.SchemaVersion != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(len(m.SchemaVersion)))
		i += copy(dAtA[i:], m.SchemaVersion)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BaseCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BaseCommand) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(*m.Type))
	}
	if m.Connect != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.Connect.Size()))
		n10, err := m.Connect.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Connected != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.Connected.Size()))
		n11, err := m.Connected.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Subscribe != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.Subscribe.Size()))
		n12, err := m.Subscribe.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.Producer != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.Producer.Size()))
		n13, err := m.Producer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Send != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.Send.Size()))
		n14, err := m.Send.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.SendReceipt != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.SendReceipt.Size()))
		n15, err := m.SendReceipt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.SendError != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.SendError.Size()))
		n16, err := m.SendError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.Message != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.Message.Size()))
		n17, err := m.Message.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.Ack != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.Ack.Size()))
		n18, err := m.Ack.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.Flow != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.Flow.Size()))
		n19, err := m.Flow.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.Unsubscribe != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.Unsubscribe.Size()))
		n20, err := m.Unsubscribe.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.Success != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.Success.Size()))
		n21, err := m.Success.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.Error != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.Error.Size()))
		n22, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.CloseProducer != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.CloseProducer.Size()))
		n23, err := m.CloseProducer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.CloseConsumer != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.CloseConsumer.Size()))
		n24, err := m.CloseConsumer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.ProducerSuccess != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.ProducerSuccess.Size()))
		n25, err := m.ProducerSuccess.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.Ping != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.Ping.Size()))
		n26, err := m.Ping.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.Pong != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.Pong.Size()))
		n27, err := m.Pong.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.RedeliverUnacknowledgedMessages != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.RedeliverUnacknowledgedMessages.Size()))
		n28, err := m.RedeliverUnacknowledgedMessages.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.PartitionMetadata != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.PartitionMetadata.Size()))
		n29, err := m.PartitionMetadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.PartitionMetadataResponse != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.PartitionMetadataResponse.Size()))
		n30, err := m.PartitionMetadataResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.LookupTopic != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.LookupTopic.Size()))
		n31, err := m.LookupTopic.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.LookupTopicResponse != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.LookupTopicResponse.Size()))
		n32, err := m.LookupTopicResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.ConsumerStats != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.ConsumerStats.Size()))
		n33, err := m.ConsumerStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.ConsumerStatsResponse != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.ConsumerStatsResponse.Size()))
		n34, err := m.ConsumerStatsResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.ReachedEndOfTopic != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.ReachedEndOfTopic.Size()))
		n35, err := m.ReachedEndOfTopic.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if m.Seek != nil {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.Seek.Size()))
		n36, err := m.Seek.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.GetLastMessageId != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.GetLastMessageId.Size()))
		n37, err := m.GetLastMessageId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if m.GetLastMessageIdResponse != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.GetLastMessageIdResponse.Size()))
		n38, err := m.GetLastMessageIdResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.ActiveConsumerChange != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.ActiveConsumerChange.Size()))
		n39, err := m.ActiveConsumerChange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if m.GetTopicsOfNamespace != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.GetTopicsOfNamespace.Size()))
		n40, err := m.GetTopicsOfNamespace.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if m.GetTopicsOfNamespaceResponse != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.GetTopicsOfNamespaceResponse.Size()))
		n41, err := m.GetTopicsOfNamespaceResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.GetSchema != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.GetSchema.Size()))
		n42, err := m.GetSchema.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if m.GetSchemaResponse != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPulsar(dAtA, i, uint64(m.GetSchemaResponse.Size()))
		n43, err := m.GetSchemaResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintPulsar(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Schema) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.SchemaData != nil {
		l = len(m.SchemaData)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.Type != nil {
		n += 1 + sovPulsar(uint64(*m.Type))
	}
	if len(m.Properties) > 0 {
		for _, e := range m.Properties {
			l = e.Size()
			n += 1 + l + sovPulsar(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageIdData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LedgerId != nil {
		n += 1 + sovPulsar(uint64(*m.LedgerId))
	}
	if m.EntryId != nil {
		n += 1 + sovPulsar(uint64(*m.EntryId))
	}
	if m.Partition != nil {
		n += 1 + sovPulsar(uint64(*m.Partition))
	}
	if m.BatchIndex != nil {
		n += 1 + sovPulsar(uint64(*m.BatchIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KeyValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = len(*m.Key)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.Value != nil {
		l = len(*m.Value)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KeyLongValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = len(*m.Key)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.Value != nil {
		n += 1 + sovPulsar(uint64(*m.Value))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EncryptionKeys) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = len(*m.Key)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.Value != nil {
		l = len(m.Value)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if len(m.Metadata) > 0 {
		for _, e := range m.Metadata {
			l = e.Size()
			n += 1 + l + sovPulsar(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProducerName != nil {
		l = len(*m.ProducerName)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.SequenceId != nil {
		n += 1 + sovPulsar(uint64(*m.SequenceId))
	}
	if m.PublishTime != nil {
		n += 1 + sovPulsar(uint64(*m.PublishTime))
	}
	if len(m.Properties) > 0 {
		for _, e := range m.Properties {
			l = e.Size()
			n += 1 + l + sovPulsar(uint64(l))
		}
	}
	if m.ReplicatedFrom != nil {
		l = len(*m.ReplicatedFrom)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.PartitionKey != nil {
		l = len(*m.PartitionKey)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if len(m.ReplicateTo) > 0 {
		for _, s := range m.ReplicateTo {
			l = len(s)
			n += 1 + l + sovPulsar(uint64(l))
		}
	}
	if m.Compression != nil {
		n += 1 + sovPulsar(uint64(*m.Compression))
	}
	if m.UncompressedSize != nil {
		n += 1 + sovPulsar(uint64(*m.UncompressedSize))
	}
	if m.NumMessagesInBatch != nil {
		n += 1 + sovPulsar(uint64(*m.NumMessagesInBatch))
	}
	if m.EventTime != nil {
		n += 1 + sovPulsar(uint64(*m.EventTime))
	}
	if len(m.EncryptionKeys) > 0 {
		for _, e := range m.EncryptionKeys {
			l = e.Size()
			n += 1 + l + sovPulsar(uint64(l))
		}
	}
	if m.EncryptionAlgo != nil {
		l = len(*m.EncryptionAlgo)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.EncryptionParam != nil {
		l = len(m.EncryptionParam)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.SchemaVersion != nil {
		l = len(m.SchemaVersion)
		n += 2 + l + sovPulsar(uint64(l))
	}
	if m.PartitionKeyB64Encoded != nil {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SingleMessageMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Properties) > 0 {
		for _, e := range m.Properties {
			l = e.Size()
			n += 1 + l + sovPulsar(uint64(l))
		}
	}
	if m.PartitionKey != nil {
		l = len(*m.PartitionKey)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.PayloadSize != nil {
		n += 1 + sovPulsar(uint64(*m.PayloadSize))
	}
	if m.CompactedOut != nil {
		n += 2
	}
	if m.EventTime != nil {
		n += 1 + sovPulsar(uint64(*m.EventTime))
	}
	if m.PartitionKeyB64Encoded != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandConnect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientVersion != nil {
		l = len(*m.ClientVersion)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.AuthMethod != nil {
		n += 1 + sovPulsar(uint64(*m.AuthMethod))
	}
	if m.AuthData != nil {
		l = len(m.AuthData)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.ProtocolVersion != nil {
		n += 1 + sovPulsar(uint64(*m.ProtocolVersion))
	}
	if m.AuthMethodName != nil {
		l = len(*m.AuthMethodName)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.ProxyToBrokerUrl != nil {
		l = len(*m.ProxyToBrokerUrl)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.OriginalPrincipal != nil {
		l = len(*m.OriginalPrincipal)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.OriginalAuthData != nil {
		l = len(*m.OriginalAuthData)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.OriginalAuthMethod != nil {
		l = len(*m.OriginalAuthMethod)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandConnected) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServerVersion != nil {
		l = len(*m.ServerVersion)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.ProtocolVersion != nil {
		n += 1 + sovPulsar(uint64(*m.ProtocolVersion))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandSubscribe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Topic != nil {
		l = len(*m.Topic)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.Subscription != nil {
		l = len(*m.Subscription)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.SubType != nil {
		n += 1 + sovPulsar(uint64(*m.SubType))
	}
	if m.ConsumerId != nil {
		n += 1 + sovPulsar(uint64(*m.ConsumerId))
	}
	if m.RequestId != nil {
		n += 1 + sovPulsar(uint64(*m.RequestId))
	}
	if m.ConsumerName != nil {
		l = len(*m.ConsumerName)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.PriorityLevel != nil {
		n += 1 + sovPulsar(uint64(*m.PriorityLevel))
	}
	if m.Durable != nil {
		n += 2
	}
	if m.StartMessageId != nil {
		l = m.StartMessageId.Size()
		n += 1 + l + sovPulsar(uint64(l))
	}
	if len(m.Metadata) > 0 {
		for _, e := range m.Metadata {
			l = e.Size()
			n += 1 + l + sovPulsar(uint64(l))
		}
	}
	if m.ReadCompacted != nil {
		n += 2
	}
	if m.Schema != nil {
		l = m.Schema.Size()
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.InitialPosition != nil {
		n += 1 + sovPulsar(uint64(*m.InitialPosition))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandPartitionedTopicMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Topic != nil {
		l = len(*m.Topic)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.RequestId != nil {
		n += 1 + sovPulsar(uint64(*m.RequestId))
	}
	if m.OriginalPrincipal != nil {
		l = len(*m.OriginalPrincipal)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.OriginalAuthData != nil {
		l = len(*m.OriginalAuthData)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.OriginalAuthMethod != nil {
		l = len(*m.OriginalAuthMethod)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandPartitionedTopicMetadataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Partitions != nil {
		n += 1 + sovPulsar(uint64(*m.Partitions))
	}
	if m.RequestId != nil {
		n += 1 + sovPulsar(uint64(*m.RequestId))
	}
	if m.Response != nil {
		n += 1 + sovPulsar(uint64(*m.Response))
	}
	if m.Error != nil {
		n += 1 + sovPulsar(uint64(*m.Error))
	}
	if m.Message != nil {
		l = len(*m.Message)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandLookupTopic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Topic != nil {
		l = len(*m.Topic)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.RequestId != nil {
		n += 1 + sovPulsar(uint64(*m.RequestId))
	}
	if m.Authoritative != nil {
		n += 2
	}
	if m.OriginalPrincipal != nil {
		l = len(*m.OriginalPrincipal)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.OriginalAuthData != nil {
		l = len(*m.OriginalAuthData)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.OriginalAuthMethod != nil {
		l = len(*m.OriginalAuthMethod)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandLookupTopicResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BrokerServiceUrl != nil {
		l = len(*m.BrokerServiceUrl)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.BrokerServiceUrlTls != nil {
		l = len(*m.BrokerServiceUrlTls)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.Response != nil {
		n += 1 + sovPulsar(uint64(*m.Response))
	}
	if m.RequestId != nil {
		n += 1 + sovPulsar(uint64(*m.RequestId))
	}
	if m.Authoritative != nil {
		n += 2
	}
	if m.Error != nil {
		n += 1 + sovPulsar(uint64(*m.Error))
	}
	if m.Message != nil {
		l = len(*m.Message)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.ProxyThroughServiceUrl != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandProducer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Topic != nil {
		l = len(*m.Topic)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.ProducerId != nil {
		n += 1 + sovPulsar(uint64(*m.ProducerId))
	}
	if m.RequestId != nil {
		n += 1 + sovPulsar(uint64(*m.RequestId))
	}
	if m.ProducerName != nil {
		l = len(*m.ProducerName)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.Encrypted != nil {
		n += 2
	}
	if len(m.Metadata) > 0 {
		for _, e := range m.Metadata {
			l = e.Size()
			n += 1 + l + sovPulsar(uint64(l))
		}
	}
	if m.Schema != nil {
		l = m.Schema.Size()
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandSend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProducerId != nil {
		n += 1 + sovPulsar(uint64(*m.ProducerId))
	}
	if m.SequenceId != nil {
		n += 1 + sovPulsar(uint64(*m.SequenceId))
	}
	if m.NumMessages != nil {
		n += 1 + sovPulsar(uint64(*m.NumMessages))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandSendReceipt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProducerId != nil {
		n += 1 + sovPulsar(uint64(*m.ProducerId))
	}
	if m.SequenceId != nil {
		n += 1 + sovPulsar(uint64(*m.SequenceId))
	}
	if m.MessageId != nil {
		l = m.MessageId.Size()
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandSendError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProducerId != nil {
		n += 1 + sovPulsar(uint64(*m.ProducerId))
	}
	if m.SequenceId != nil {
		n += 1 + sovPulsar(uint64(*m.SequenceId))
	}
	if m.Error != nil {
		n += 1 + sovPulsar(uint64(*m.Error))
	}
	if m.Message != nil {
		l = len(*m.Message)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConsumerId != nil {
		n += 1 + sovPulsar(uint64(*m.ConsumerId))
	}
	if m.MessageId != nil {
		l = m.MessageId.Size()
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.RedeliveryCount != nil {
		n += 1 + sovPulsar(uint64(*m.RedeliveryCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConsumerId != nil {
		n += 1 + sovPulsar(uint64(*m.ConsumerId))
	}
	if m.AckType != nil {
		n += 1 + sovPulsar(uint64(*m.AckType))
	}
	if len(m.MessageId) > 0 {
		for _, e := range m.MessageId {
			l = e.Size()
			n += 1 + l + sovPulsar(uint64(l))
		}
	}
	if m.ValidationError != nil {
		n += 1 + sovPulsar(uint64(*m.ValidationError))
	}
	if len(m.Properties) > 0 {
		for _, e := range m.Properties {
			l = e.Size()
			n += 1 + l + sovPulsar(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandActiveConsumerChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConsumerId != nil {
		n += 1 + sovPulsar(uint64(*m.ConsumerId))
	}
	if m.IsActive != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandFlow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConsumerId != nil {
		n += 1 + sovPulsar(uint64(*m.ConsumerId))
	}
	if m.MessagePermits != nil {
		n += 1 + sovPulsar(uint64(*m.MessagePermits))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandUnsubscribe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConsumerId != nil {
		n += 1 + sovPulsar(uint64(*m.ConsumerId))
	}
	if m.RequestId != nil {
		n += 1 + sovPulsar(uint64(*m.RequestId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandSeek) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConsumerId != nil {
		n += 1 + sovPulsar(uint64(*m.ConsumerId))
	}
	if m.RequestId != nil {
		n += 1 + sovPulsar(uint64(*m.RequestId))
	}
	if m.MessageId != nil {
		l = m.MessageId.Size()
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandReachedEndOfTopic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConsumerId != nil {
		n += 1 + sovPulsar(uint64(*m.ConsumerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandCloseProducer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProducerId != nil {
		n += 1 + sovPulsar(uint64(*m.ProducerId))
	}
	if m.RequestId != nil {
		n += 1 + sovPulsar(uint64(*m.RequestId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandCloseConsumer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConsumerId != nil {
		n += 1 + sovPulsar(uint64(*m.ConsumerId))
	}
	if m.RequestId != nil {
		n += 1 + sovPulsar(uint64(*m.RequestId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandRedeliverUnacknowledgedMessages) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConsumerId != nil {
		n += 1 + sovPulsar(uint64(*m.ConsumerId))
	}
	if len(m.MessageIds) > 0 {
		for _, e := range m.MessageIds {
			l = e.Size()
			n += 1 + l + sovPulsar(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandSuccess) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestId != nil {
		n += 1 + sovPulsar(uint64(*m.RequestId))
	}
	if m.Schema != nil {
		l = m.Schema.Size()
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandProducerSuccess) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestId != nil {
		n += 1 + sovPulsar(uint64(*m.RequestId))
	}
	if m.ProducerName != nil {
		l = len(*m.ProducerName)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.LastSequenceId != nil {
		n += 1 + sovPulsar(uint64(*m.LastSequenceId))
	}
	if m.SchemaVersion != nil {
		l = len(m.SchemaVersion)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestId != nil {
		n += 1 + sovPulsar(uint64(*m.RequestId))
	}
	if m.Error != nil {
		n += 1 + sovPulsar(uint64(*m.Error))
	}
	if m.Message != nil {
		l = len(*m.Message)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandPing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandPong) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandConsumerStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestId != nil {
		n += 1 + sovPulsar(uint64(*m.RequestId))
	}
	if m.ConsumerId != nil {
		n += 1 + sovPulsar(uint64(*m.ConsumerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandConsumerStatsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestId != nil {
		n += 1 + sovPulsar(uint64(*m.RequestId))
	}
	if m.ErrorCode != nil {
		n += 1 + sovPulsar(uint64(*m.ErrorCode))
	}
	if m.ErrorMessage != nil {
		l = len(*m.ErrorMessage)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.MsgRateOut != nil {
		n += 9
	}
	if m.MsgThroughputOut != nil {
		n += 9
	}
	if m.MsgRateRedeliver != nil {
		n += 9
	}
	if m.ConsumerName != nil {
		l = len(*m.ConsumerName)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.AvailablePermits != nil {
		n += 1 + sovPulsar(uint64(*m.AvailablePermits))
	}
	if m.UnackedMessages != nil {
		n += 1 + sovPulsar(uint64(*m.UnackedMessages))
	}
	if m.BlockedConsumerOnUnackedMsgs != nil {
		n += 2
	}
	if m.Address != nil {
		l = len(*m.Address)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.ConnectedSince != nil {
		l = len(*m.ConnectedSince)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.Type != nil {
		l = len(*m.Type)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.MsgRateExpired != nil {
		n += 9
	}
	if m.MsgBacklog != nil {
		n += 1 + sovPulsar(uint64(*m.MsgBacklog))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandGetLastMessageId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConsumerId != nil {
		n += 1 + sovPulsar(uint64(*m.ConsumerId))
	}
	if m.RequestId != nil {
		n += 1 + sovPulsar(uint64(*m.RequestId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandGetLastMessageIdResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LastMessageId != nil {
		l = m.LastMessageId.Size()
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.RequestId != nil {
		n += 1 + sovPulsar(uint64(*m.RequestId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandGetTopicsOfNamespace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestId != nil {
		n += 1 + sovPulsar(uint64(*m.RequestId))
	}
	if m.Namespace != nil {
		l = len(*m.Namespace)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.Mode != nil {
		n += 1 + sovPulsar(uint64(*m.Mode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandGetTopicsOfNamespaceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestId != nil {
		n += 1 + sovPulsar(uint64(*m.RequestId))
	}
	if len(m.Topics) > 0 {
		for _, s := range m.Topics {
			l = len(s)
			n += 1 + l + sovPulsar(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandGetSchema) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestId != nil {
		n += 1 + sovPulsar(uint64(*m.RequestId))
	}
	if m.Topic != nil {
		l = len(*m.Topic)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.SchemaVersion != nil {
		l = len(m.SchemaVersion)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandGetSchemaResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestId != nil {
		n += 1 + sovPulsar(uint64(*m.RequestId))
	}
	if m.ErrorCode != nil {
		n += 1 + sovPulsar(uint64(*m.ErrorCode))
	}
	if m.ErrorMessage != nil {
		l = len(*m.ErrorMessage)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.Schema != nil {
		l = m.Schema.Size()
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.SchemaVersion != nil {
		l = len(m.SchemaVersion)
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BaseCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sovPulsar(uint64(*m.Type))
	}
	if m.Connect != nil {
		l = m.Connect.Size()
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.Connected != nil {
		l = m.Connected.Size()
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.Subscribe != nil {
		l = m.Subscribe.Size()
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.Producer != nil {
		l = m.Producer.Size()
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.Send != nil {
		l = m.Send.Size()
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.SendReceipt != nil {
		l = m.SendReceipt.Size()
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.SendError != nil {
		l = m.SendError.Size()
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.Ack != nil {
		l = m.Ack.Size()
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.Flow != nil {
		l = m.Flow.Size()
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.Unsubscribe != nil {
		l = m.Unsubscribe.Size()
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.Success != nil {
		l = m.Success.Size()
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.CloseProducer != nil {
		l = m.CloseProducer.Size()
		n += 1 + l + sovPulsar(uint64(l))
	}
	if m.CloseConsumer != nil {
		l = m.CloseConsumer.Size()
		n += 2 + l + sovPulsar(uint64(l))
	}
	if m.ProducerSuccess != nil {
		l = m.ProducerSuccess.Size()
		n += 2 + l + sovPulsar(uint64(l))
	}
	if m.Ping != nil {
		l = m.Ping.Size()
		n += 2 + l + sovPulsar(uint64(l))
	}
	if m.Pong != nil {
		l = m.Pong.Size()
		n += 2 + l + sovPulsar(uint64(l))
	}
	if m.RedeliverUnacknowledgedMessages != nil {
		l = m.RedeliverUnacknowledgedMessages.Size()
		n += 2 + l + sovPulsar(uint64(l))
	}
	if m.PartitionMetadata != nil {
		l = m.PartitionMetadata.Size()
		n += 2 + l + sovPulsar(uint64(l))
	}
	if m.PartitionMetadataResponse != nil {
		l = m.PartitionMetadataResponse.Size()
		n += 2 + l + sovPulsar(uint64(l))
	}
	if m.LookupTopic != nil {
		l = m.LookupTopic.Size()
		n += 2 + l + sovPulsar(uint64(l))
	}
	if m.LookupTopicResponse != nil {
		l = m.LookupTopicResponse.Size()
		n += 2 + l + sovPulsar(uint64(l))
	}
	if m.ConsumerStats != nil {
		l = m.ConsumerStats.Size()
		n += 2 + l + sovPulsar(uint64(l))
	}
	if m.ConsumerStatsResponse != nil {
		l = m.ConsumerStatsResponse.Size()
		n += 2 + l + sovPulsar(uint64(l))
	}
	if m.ReachedEndOfTopic != nil {
		l = m.ReachedEndOfTopic.Size()
		n += 2 + l + sovPulsar(uint64(l))
	}
	if m.Seek != nil {
		l = m.Seek.Size()
		n += 2 + l + sovPulsar(uint64(l))
	}
	if m.GetLastMessageId != nil {
		l = m.GetLastMessageId.Size()
		n += 2 + l + sovPulsar(uint64(l))
	}
	if m.GetLastMessageIdResponse != nil {
		l = m.GetLastMessageIdResponse.Size()
		n += 2 + l + sovPulsar(uint64(l))
	}
	if m.ActiveConsumerChange != nil {
		l = m.ActiveConsumerChange.Size()
		n += 2 + l + sovPulsar(uint64(l))
	}
	if m.GetTopicsOfNamespace != nil {
		l = m.GetTopicsOfNamespace.Size()
		n += 2 + l + sovPulsar(uint64(l))
	}
	if m.GetTopicsOfNamespaceResponse != nil {
		l = m.GetTopicsOfNamespaceResponse.Size()
		n += 2 + l + sovPulsar(uint64(l))
	}
	if m.GetSchema != nil {
		l = m.GetSchema.Size()
		n += 2 + l + sovPulsar(uint64(l))
	}
	if m.GetSchemaResponse != nil {
		l = m.GetSchemaResponse.Size()
		n += 2 + l + sovPulsar(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPulsar(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozPulsar(x uint64) (n int) {
	return sovPulsar(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Schema) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Schema: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Schema: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaData = append(m.SchemaData[:0], dAtA[iNdEx:postIndex]...)
			if m.SchemaData == nil {
				m.SchemaData = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v Schema_Type
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (Schema_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
			hasFields[0] |= uint64(0x00000004)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Properties = append(m.Properties, &KeyValue{})
			if err := m.Properties[len(m.Properties)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageIdData) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageIdData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageIdData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LedgerId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LedgerId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EntryId = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Partition = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchIndex", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BatchIndex = &v
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyValue) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Key = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Value = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyLongValue) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyLongValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyLongValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Key = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptionKeys) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptionKeys: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptionKeys: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Key = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = append(m.Metadata, &KeyValue{})
			if err := m.Metadata[len(m.Metadata)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageMetadata) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProducerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ProducerName = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SequenceId = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublishTime", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PublishTime = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Properties = append(m.Properties, &KeyValue{})
			if err := m.Properties[len(m.Properties)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicatedFrom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ReplicatedFrom = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PartitionKey = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicateTo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplicateTo = append(m.ReplicateTo, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compression", wireType)
			}
			var v CompressionType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (CompressionType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Compression = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UncompressedSize", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UncompressedSize = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumMessagesInBatch", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NumMessagesInBatch = &v
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventTime", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EventTime = &v
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptionKeys = append(m.EncryptionKeys, &EncryptionKeys{})
			if err := m.EncryptionKeys[len(m.EncryptionKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionAlgo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.EncryptionAlgo = &s
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionParam", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptionParam = append(m.EncryptionParam[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptionParam == nil {
				m.EncryptionParam = []byte{}
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaVersion", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaVersion = append(m.SchemaVersion[:0], dAtA[iNdEx:postIndex]...)
			if m.SchemaVersion == nil {
				m.SchemaVersion = []byte{}
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionKeyB64Encoded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.PartitionKeyB64Encoded = &b
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SingleMessageMetadata) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SingleMessageMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SingleMessageMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Properties = append(m.Properties, &KeyValue{})
			if err := m.Properties[len(m.Properties)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PartitionKey = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadSize", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PayloadSize = &v
			hasFields[0] |= uint64(0x00000001)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactedOut", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.CompactedOut = &b
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventTime", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EventTime = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionKeyB64Encoded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.PartitionKeyB64Encoded = &b
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandConnect) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandConnect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandConnect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ClientVersion = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthMethod", wireType)
			}
			var v AuthMethod
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (AuthMethod(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AuthMethod = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthData = append(m.AuthData[:0], dAtA[iNdEx:postIndex]...)
			if m.AuthData == nil {
				m.AuthData = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolVersion", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ProtocolVersion = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthMethodName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.AuthMethodName = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyToBrokerUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ProxyToBrokerUrl = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalPrincipal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OriginalPrincipal = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalAuthData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OriginalAuthData = &s
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalAuthMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OriginalAuthMethod = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandConnected) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandConnected: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandConnected: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ServerVersion = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolVersion", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ProtocolVersion = &v
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandSubscribe) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandSubscribe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandSubscribe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Topic = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Subscription = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubType", wireType)
			}
			var v CommandSubscribe_SubType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (CommandSubscribe_SubType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SubType = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConsumerId = &v
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequestId = &v
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ConsumerName = &s
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriorityLevel", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PriorityLevel = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Durable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Durable = &b
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartMessageId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartMessageId == nil {
				m.StartMessageId = &MessageIdData{}
			}
			if err := m.StartMessageId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = append(m.Metadata, &KeyValue{})
			if err := m.Metadata[len(m.Metadata)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadCompacted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ReadCompacted = &b
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Schema == nil {
				m.Schema = &Schema{}
			}
			if err := m.Schema.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialPosition", wireType)
			}
			var v CommandSubscribe_InitialPosition
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (CommandSubscribe_InitialPosition(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InitialPosition = &v
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandPartitionedTopicMetadata) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandPartitionedTopicMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandPartitionedTopicMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Topic = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequestId = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalPrincipal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OriginalPrincipal = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalAuthData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OriginalAuthData = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalAuthMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OriginalAuthMethod = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandPartitionedTopicMetadataResponse) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandPartitionedTopicMetadataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandPartitionedTopicMetadataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partitions", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Partitions = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequestId = &v
			hasFields[0] |= uint64(0x00000001)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var v CommandPartitionedTopicMetadataResponse_LookupType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (CommandPartitionedTopicMetadataResponse_LookupType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Response = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var v ServerError
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (ServerError(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Error = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Message = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandLookupTopic) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandLookupTopic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandLookupTopic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Topic = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequestId = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authoritative", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Authoritative = &b
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalPrincipal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OriginalPrincipal = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalAuthData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OriginalAuthData = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalAuthMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OriginalAuthMethod = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandLookupTopicResponse) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandLookupTopicResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandLookupTopicResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BrokerServiceUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.BrokerServiceUrl = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BrokerServiceUrlTls", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.BrokerServiceUrlTls = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var v CommandLookupTopicResponse_LookupType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (CommandLookupTopicResponse_LookupType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Response = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequestId = &v
			hasFields[0] |= uint64(0x00000001)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authoritative", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Authoritative = &b
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var v ServerError
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (ServerError(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Error = &v
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Message = &s
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyThroughServiceUrl", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ProxyThroughServiceUrl = &b
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandProducer) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandProducer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandProducer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Topic = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProducerId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ProducerId = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequestId = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProducerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ProducerName = &s
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encrypted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Encrypted = &b
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = append(m.Metadata, &KeyValue{})
			if err := m.Metadata[len(m.Metadata)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Schema == nil {
				m.Schema = &Schema{}
			}
			if err := m.Schema.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandSend) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandSend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandSend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProducerId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ProducerId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SequenceId = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumMessages", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NumMessages = &v
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandSendReceipt) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandSendReceipt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandSendReceipt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProducerId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ProducerId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SequenceId = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MessageId == nil {
				m.MessageId = &MessageIdData{}
			}
			if err := m.MessageId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandSendError) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandSendError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandSendError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProducerId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ProducerId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SequenceId = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var v ServerError
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (ServerError(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Error = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Message = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandMessage) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConsumerId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MessageId == nil {
				m.MessageId = &MessageIdData{}
			}
			if err := m.MessageId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedeliveryCount", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RedeliveryCount = &v
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandAck) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConsumerId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AckType", wireType)
			}
			var v CommandAck_AckType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (CommandAck_AckType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AckType = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageId = append(m.MessageId, &MessageIdData{})
			if err := m.MessageId[len(m.MessageId)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidationError", wireType)
			}
			var v CommandAck_ValidationError
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (CommandAck_ValidationError(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ValidationError = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Properties = append(m.Properties, &KeyLongValue{})
			if err := m.Properties[len(m.Properties)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandActiveConsumerChange) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandActiveConsumerChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandActiveConsumerChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConsumerId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsActive = &b
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandFlow) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandFlow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandFlow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConsumerId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessagePermits", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MessagePermits = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandUnsubscribe) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandUnsubscribe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandUnsubscribe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConsumerId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequestId = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandSeek) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandSeek: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandSeek: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConsumerId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequestId = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MessageId == nil {
				m.MessageId = &MessageIdData{}
			}
			if err := m.MessageId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandReachedEndOfTopic) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandReachedEndOfTopic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandReachedEndOfTopic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConsumerId = &v
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandCloseProducer) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandCloseProducer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandCloseProducer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProducerId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ProducerId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequestId = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandCloseConsumer) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandCloseConsumer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandCloseConsumer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConsumerId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequestId = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandRedeliverUnacknowledgedMessages) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandRedeliverUnacknowledgedMessages: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandRedeliverUnacknowledgedMessages: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConsumerId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageIds = append(m.MessageIds, &MessageIdData{})
			if err := m.MessageIds[len(m.MessageIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandSuccess) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandSuccess: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandSuccess: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequestId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Schema == nil {
				m.Schema = &Schema{}
			}
			if err := m.Schema.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandProducerSuccess) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandProducerSuccess: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandProducerSuccess: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequestId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProducerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ProducerName = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSequenceId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LastSequenceId = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaVersion", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaVersion = append(m.SchemaVersion[:0], dAtA[iNdEx:postIndex]...)
			if m.SchemaVersion == nil {
				m.SchemaVersion = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandError) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequestId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var v ServerError
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (ServerError(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Error = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Message = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandPing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandPing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandPing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandPong) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandPong: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandPong: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandConsumerStats) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandConsumerStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandConsumerStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequestId = &v
			hasFields[0] |= uint64(0x00000001)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConsumerId = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandConsumerStatsResponse) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandConsumerStatsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandConsumerStatsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequestId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			var v ServerError
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (ServerError(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ErrorCode = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ErrorMessage = &s
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgRateOut", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.MsgRateOut = &v2
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgThroughputOut", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.MsgThroughputOut = &v2
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgRateRedeliver", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.MsgRateRedeliver = &v2
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ConsumerName = &s
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailablePermits", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AvailablePermits = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnackedMessages", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UnackedMessages = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockedConsumerOnUnackedMsgs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.BlockedConsumerOnUnackedMsgs = &b
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Address = &s
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectedSince", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ConnectedSince = &s
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Type = &s
			iNdEx = postIndex
		case 14:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgRateExpired", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.MsgRateExpired = &v2
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgBacklog", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MsgBacklog = &v
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandGetLastMessageId) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandGetLastMessageId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandGetLastMessageId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConsumerId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequestId = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandGetLastMessageIdResponse) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandGetLastMessageIdResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandGetLastMessageIdResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastMessageId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastMessageId == nil {
				m.LastMessageId = &MessageIdData{}
			}
			if err := m.LastMessageId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequestId = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandGetTopicsOfNamespace) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandGetTopicsOfNamespace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandGetTopicsOfNamespace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequestId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Namespace = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var v CommandGetTopicsOfNamespace_Mode
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (CommandGetTopicsOfNamespace_Mode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mode = &v
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandGetTopicsOfNamespaceResponse) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandGetTopicsOfNamespaceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandGetTopicsOfNamespaceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequestId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topics", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topics = append(m.Topics, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandGetSchema) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandGetSchema: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandGetSchema: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequestId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Topic = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaVersion", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaVersion = append(m.SchemaVersion[:0], dAtA[iNdEx:postIndex]...)
			if m.SchemaVersion == nil {
				m.SchemaVersion = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandGetSchemaResponse) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandGetSchemaResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandGetSchemaResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequestId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			var v ServerError
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (ServerError(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ErrorCode = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ErrorMessage = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Schema == nil {
				m.Schema = &Schema{}
			}
			if err := m.Schema.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaVersion", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaVersion = append(m.SchemaVersion[:0], dAtA[iNdEx:postIndex]...)
			if m.SchemaVersion == nil {
				m.SchemaVersion = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BaseCommand) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BaseCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BaseCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v BaseCommand_Type
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (BaseCommand_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Connect == nil {
				m.Connect = &CommandConnect{}
			}
			if err := m.Connect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connected", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Connected == nil {
				m.Connected = &CommandConnected{}
			}
			if err := m.Connected.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscribe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Subscribe == nil {
				m.Subscribe = &CommandSubscribe{}
			}
			if err := m.Subscribe.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Producer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Producer == nil {
				m.Producer = &CommandProducer{}
			}
			if err := m.Producer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Send", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Send == nil {
				m.Send = &CommandSend{}
			}
			if err := m.Send.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendReceipt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SendReceipt == nil {
				m.SendReceipt = &CommandSendReceipt{}
			}
			if err := m.SendReceipt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SendError == nil {
				m.SendError = &CommandSendError{}
			}
			if err := m.SendError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &CommandMessage{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ack", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ack == nil {
				m.Ack = &CommandAck{}
			}
			if err := m.Ack.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Flow == nil {
				m.Flow = &CommandFlow{}
			}
			if err := m.Flow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unsubscribe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Unsubscribe == nil {
				m.Unsubscribe = &CommandUnsubscribe{}
			}
			if err := m.Unsubscribe.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Success == nil {
				m.Success = &CommandSuccess{}
			}
			if err := m.Success.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &CommandError{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseProducer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseProducer == nil {
				m.CloseProducer = &CommandCloseProducer{}
			}
			if err := m.CloseProducer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseConsumer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseConsumer == nil {
				m.CloseConsumer = &CommandCloseConsumer{}
			}
			if err := m.CloseConsumer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProducerSuccess", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProducerSuccess == nil {
				m.ProducerSuccess = &CommandProducerSuccess{}
			}
			if err := m.ProducerSuccess.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ping == nil {
				m.Ping = &CommandPing{}
			}
			if err := m.Ping.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pong", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pong == nil {
				m.Pong = &CommandPong{}
			}
			if err := m.Pong.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedeliverUnacknowledgedMessages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RedeliverUnacknowledgedMessages == nil {
				m.RedeliverUnacknowledgedMessages = &CommandRedeliverUnacknowledgedMessages{}
			}
			if err := m.RedeliverUnacknowledgedMessages.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PartitionMetadata == nil {
				m.PartitionMetadata = &CommandPartitionedTopicMetadata{}
			}
			if err := m.PartitionMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionMetadataResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PartitionMetadataResponse == nil {
				m.PartitionMetadataResponse = &CommandPartitionedTopicMetadataResponse{}
			}
			if err := m.PartitionMetadataResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LookupTopic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LookupTopic == nil {
				m.LookupTopic = &CommandLookupTopic{}
			}
			if err := m.LookupTopic.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LookupTopicResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LookupTopicResponse == nil {
				m.LookupTopicResponse = &CommandLookupTopicResponse{}
			}
			if err := m.LookupTopicResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConsumerStats == nil {
				m.ConsumerStats = &CommandConsumerStats{}
			}
			if err := m.ConsumerStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerStatsResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConsumerStatsResponse == nil {
				m.ConsumerStatsResponse = &CommandConsumerStatsResponse{}
			}
			if err := m.ConsumerStatsResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReachedEndOfTopic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReachedEndOfTopic == nil {
				m.ReachedEndOfTopic = &CommandReachedEndOfTopic{}
			}
			if err := m.ReachedEndOfTopic.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seek", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Seek == nil {
				m.Seek = &CommandSeek{}
			}
			if err := m.Seek.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetLastMessageId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GetLastMessageId == nil {
				m.GetLastMessageId = &CommandGetLastMessageId{}
			}
			if err := m.GetLastMessageId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetLastMessageIdResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GetLastMessageIdResponse == nil {
				m.GetLastMessageIdResponse = &CommandGetLastMessageIdResponse{}
			}
			if err := m.GetLastMessageIdResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveConsumerChange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActiveConsumerChange == nil {
				m.ActiveConsumerChange = &CommandActiveConsumerChange{}
			}
			if err := m.ActiveConsumerChange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetTopicsOfNamespace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GetTopicsOfNamespace == nil {
				m.GetTopicsOfNamespace = &CommandGetTopicsOfNamespace{}
			}
			if err := m.GetTopicsOfNamespace.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetTopicsOfNamespaceResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GetTopicsOfNamespaceResponse == nil {
				m.GetTopicsOfNamespaceResponse = &CommandGetTopicsOfNamespaceResponse{}
			}
			if err := m.GetTopicsOfNamespaceResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetSchema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GetSchema == nil {
				m.GetSchema = &CommandGetSchema{}
			}
			if err := m.GetSchema.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetSchemaResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPulsar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GetSchemaResponse == nil {
				m.GetSchemaResponse = &CommandGetSchemaResponse{}
			}
			if err := m.GetSchemaResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPulsar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPulsar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPulsar(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPulsar
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPulsar
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthPulsar
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPulsar
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPulsar(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPulsar = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPulsar   = fmt.Errorf("proto: integer overflow")
)
